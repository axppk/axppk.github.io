[{"content":"前期准备 安装 JDK 17 以上 安装 Idea 2021.3 以上 创建项目 Idea 直接创建 springboot 或通过 Spring 官网在线 创建出来导入 Idea 项目结构 基本知识 前提了解 ORM 前提了解 mybatis 与 springboot data jpa 的区别 JPA + Hibernate + springboot data jpa JPA 和 springboot data jpa 的区别 Mynatis-plus 介绍 目前在用 一种是 Mybatis\n另一种是 Hibernate + JPA + Spring Data JPA\n实例示例（以 Springboot 与 Hibernate + JPA + Spring Data JPA 为例） 基本结构如下\n实体类 @Entity 实体类注解，表示这是一个实体类，可以被 JPA 识别\n@Table 表名注解，可以指定表名\n@Id 主键注解，可以指定主键\n@GeneratedValue 主键生成策略注解，可以指定主键生成策略\n@Column 列注解，可以指定列名，列类型，是否可空等属性\n实体类(entity) 控制器层 @RestController 控制器层注解，表示这是一个控制器类，可以返回 json 数据 @RequestMapping 请求映射注解，可以指定请求路径 @Autowired 自动注入注解，可以自动注入相应的类 @PathVariable 路径参数注解，可以获取路径参数 @RequestParam 请求参数注解，可以获取请求参数 @RequestBody 请求体注解，可以获取请求体 @ResponseBody 响应体注解，可以返回响应体 @ExceptionHandler 异常处理注解，可以处理异常 @GetMapping 获取请求注解，可以指定 GET 请求路径\n@PostMapping 新增请求注解，可以指定 POST 请求路径\n@PutMapping 更新请求注解，可以指定 PUT 请求路径\n@DeleteMapping 删除请求注解，可以指定 DELETE 请求路径\n控制器层接口(controller) 数据层 @Repository 数据层注解，表示这是一个数据访问类，可以访问数据库\n@Query 查询注解，可以指定查询语句\n@Modifying 修改注解，可以指定修改语句\n数据层实现(repository) 服务层 @Service 服务层注解，表示这是一个服务类，可以实现业务逻辑\n@Autowired 自动注入注解，可以自动注入相应的类\n@Transactional 事务注解，可以实现事务操作\n服务层接口(service) application.properties pom.xml Hibernate 整合 引入依赖 引入 Hibernate 依赖，并引入 mysql-connector-j 依赖 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-jpa\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-j\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 快速创建实体类 参考连接数据库时操作 实例示例（以 springboot 与 mybatis-plus 为例） 基本结构如下 这里只展示 mybatis-plus 多出来的几个结构 DTO DTO Mapper Mapper Mapper.xml（这个文件是 mybatis 映射文件，可以自定义 sql 语句，当自带的库不能满足需求时，可以自己写） implement -impl（implement） Mybatis-plus 整合 引入依赖 并非只有单纯的 mybatis-plus，还可以引入 springboot-starter-web，lombok，validation，mysql-connector-j 依赖 lombok 用于省略 getter/setter 方法（数据库字段不规范将会在导致通信时字段名大小写不一致，badrequest 异常原因之一） validation 用于校验 mysql-connector-j 用于连接数据库 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- lombok --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- test --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Validation --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-validation\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- MyBatis-Plus Starter (这是唯一需要的 MyBatis 相关依赖) --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus-spring-boot3-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.7\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- MySQL Driver --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-j\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 快速创建结构 可以通过 idea 插件（mybatis-plus）快速创建 mybatis-plus 相关结构\n首先连接数据库，记得改成自己的数据库名字（此处为 soilerosion）\n点击创建，会自动生成实体类，mapper 接口，mapper.xml 等文件 特殊点 需要设置 Mapper 的扫描路径(记得导入下扫描的包) 1 import org.mybatis.spring.annotation.MapperScan; 运行项目 右键项目 -\u0026gt; Run \u0026lsquo;Application\u0026rsquo; 连接数据库 idea 右侧有数据库连接插件，选择对应的服务器，这里以 mysql 为例 填写 localhost，端口号，用户名，密码，数据库名 点击测试连接，如果连接成功，则会出现一个绿色的勾（记得按提示安装驱动） 装 JPA 模块，这里以 Hibernate 为例，可以实现自动将表创建为实体类 由于上述操作是通过 idea 集成的插件做的，所以项目中其实没有配置数据源，需要在 application.properties 中配置数据源信息，同时在 pom.xml 中引入依赖\n配置数据源\n1 2 3 4 spring.datasource.url=jdbc:mysql://localhost:3306/soilerosion spring.datasource.username=root spring.datasource.password=123321 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver 引入依赖(也可以通过 idea 集成的插件快速引入，搜名字就行) 1 2 3 4 5 6 7 8 9 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-jpa\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-j\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 测试 下面是各层的代码实现简单增删改查 实体类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package com.example.springboottest3.entity; import com.baomidou.mybatisplus.annotation.TableName; import com.baomidou.mybatisplus.annotation.IdType; import com.baomidou.mybatisplus.annotation.TableId; import java.io.Serializable; import lombok.Data; import lombok.EqualsAndHashCode; import lombok.experimental.Accessors; /** * \u0026lt;p\u0026gt; * * \u0026lt;/p\u0026gt; * * @author author * @since 2025-10-31 */ @Data @EqualsAndHashCode(callSuper = false) @Accessors(chain = true) @TableName(\u0026#34;user\u0026#34;) public class User implements Serializable { private static final long serialVersionUID = 1L; @TableId(value = \u0026#34;id\u0026#34;, type = IdType.AUTO) private Integer id; private String uName; private String uPassword; } DTO 1 2 3 4 5 6 7 8 9 10 11 // src/main/java/com/example/springboottest2/dto/UserDTO.java package com.example.springboottest3.dto; import lombok.Data; @Data public class UserDTO { private Integer id; private String uName; // 注意：这里不包含 uPassword，保护敏感信息 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // src/main/java/com/example/springboottest2/dto/UserCreateDTO.java package com.example.springboottest3.dto; import jakarta.validation.constraints.NotBlank; import com.fasterxml.jackson.annotation.JsonProperty; // 需导入依赖（spring-boot-starter-web已包含） import lombok.Data; @Data public class UserCreateDTO { @NotBlank(message = \u0026#34;用户名不能为空\u0026#34;) @JsonProperty(\u0026#34;uName\u0026#34;) // 强制绑定JSON的uName键 private String uName; @NotBlank(message = \u0026#34;密码不能为空\u0026#34;) @JsonProperty(\u0026#34;uPassword\u0026#34;) // 强制绑定JSON的uPassword键 private String uPassword; // 临时添加，测试Lombok是否生效 public void printFields() { System.out.println(\u0026#34;uName: \u0026#34; + uName); System.out.println(\u0026#34;uPassword: \u0026#34; + uPassword); } } Mapper 1 2 3 4 5 6 7 8 // src/main/java/com/example/springboottest2/mapper/UserMapper.java package com.example.springboottest3.mapper; import com.baomidou.mybatisplus.core.mapper.BaseMapper; import com.example.springboottest3.entity.User; public interface UserMapper extends BaseMapper\u0026lt;User\u0026gt; { } impl 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 // src/main/java/com/example/springboottest2/service/impl/UserServiceImpl.java package com.example.springboottest3.service.impl; import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl; import com.example.springboottest3.dto.UserCreateDTO; import com.example.springboottest3.dto.UserDTO; import com.example.springboottest3.entity.User; import com.example.springboottest3.mapper.UserMapper; import com.example.springboottest3.service.UserService; import org.springframework.beans.BeanUtils; import org.springframework.stereotype.Service; import org.springframework.util.StringUtils; import java.util.List; import java.util.stream.Collectors; @Service public class UserServiceImpl extends ServiceImpl\u0026lt;UserMapper, User\u0026gt; implements UserService { /** * 将 User Entity 转换为 UserDTO */ private UserDTO convertToDTO(User user) { UserDTO userDTO = new UserDTO(); BeanUtils.copyProperties(user, userDTO); return userDTO; } /** * 将 UserCreateDTO 转换为 User Entity */ private User convertToEntity(UserCreateDTO createDTO) { User user = new User(); BeanUtils.copyProperties(createDTO, user); return user; } @Override public UserDTO createUser(UserCreateDTO createDTO) { User user = convertToEntity(createDTO); // ✅ 使用父类 ServiceImpl 提供的 save() 方法 this.save(user); return convertToDTO(user); } @Override public UserDTO getUserById(Integer id) { // ✅ 使用父类 ServiceImpl 提供的 getById() 方法 User user = this.getById(id); return user != null ? convertToDTO(user) : null; } @Override public List\u0026lt;UserDTO\u0026gt; listAllUsers() { // ✅ 使用父类 ServiceImpl 提供的 list() 方法 List\u0026lt;User\u0026gt; users = this.list(); return users.stream().map(this::convertToDTO).collect(Collectors.toList()); } @Override public UserDTO updateUser(Integer id, UserCreateDTO updateDTO) { User existingUser = this.getById(id); if (existingUser == null) { return null; } if (StringUtils.hasText(updateDTO.getUName())) { existingUser.setUName(updateDTO.getUName()); } if (StringUtils.hasText(updateDTO.getUPassword())) { existingUser.setUPassword(updateDTO.getUPassword()); } // ✅ 使用父类 ServiceImpl 提供的 updateById() 方法 this.updateById(existingUser); return convertToDTO(existingUser); } @Override public boolean deleteUser(Integer id) { // ✅ 使用父类 ServiceImpl 提供的 removeById() 方法 return this.removeById(id); } } service 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // src/main/java/com/example/springboottest2/service/UserService.java package com.example.springboottest3.service; import com.baomidou.mybatisplus.extension.service.IService; import com.example.springboottest3.dto.UserDTO; import com.example.springboottest3.dto.UserCreateDTO; import com.example.springboottest3.entity.User; import java.util.List; public interface UserService extends IService\u0026lt;User\u0026gt; { // 注意，IService的泛型仍然是Entity /** * 创建用户 */ UserDTO createUser(UserCreateDTO createDTO); /** * 根据ID获取用户信息 */ UserDTO getUserById(Integer id); /** * 获取所有用户 */ List\u0026lt;UserDTO\u0026gt; listAllUsers(); /** * 更新用户 */ UserDTO updateUser(Integer id, UserCreateDTO updateDTO); /** * 删除用户 */ boolean deleteUser(Integer id); } controller 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 // src/main/java/com/example/springboottest2/controller/UserController.java package com.example.springboottest3.controller; import com.example.springboottest3.dto.UserCreateDTO; import com.example.springboottest3.dto.UserDTO; import com.example.springboottest3.service.UserService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.validation.annotation.Validated; import org.springframework.web.bind.annotation.*; import jakarta.validation.Valid; import java.util.List; @RestController @RequestMapping(\u0026#34;/api/users\u0026#34;) @Validated // 开启参数校验 public class UserController { @Autowired private UserService userService; // 创建用户 @PostMapping public ResponseEntity\u0026lt;UserDTO\u0026gt; createUser(@Valid @RequestBody UserCreateDTO userCreateDTO) { userCreateDTO.printFields(); // 打印参数 UserDTO createdUser = userService.createUser(userCreateDTO); return new ResponseEntity\u0026lt;\u0026gt;(createdUser, HttpStatus.CREATED); } // 根据 ID 获取用户 @GetMapping(\u0026#34;/{id}\u0026#34;) public ResponseEntity\u0026lt;UserDTO\u0026gt; getUserById(@PathVariable Integer id) { UserDTO user = userService.getUserById(id); if (user != null) { return ResponseEntity.ok(user); } return ResponseEntity.notFound().build(); } // 获取所有用户 @GetMapping public ResponseEntity\u0026lt;List\u0026lt;UserDTO\u0026gt;\u0026gt; getAllUsers() { List\u0026lt;UserDTO\u0026gt; users = userService.listAllUsers(); return ResponseEntity.ok(users); } // 更新用户 @PutMapping(\u0026#34;/{id}\u0026#34;) public ResponseEntity\u0026lt;UserDTO\u0026gt; updateUser(@PathVariable Integer id, @Valid @RequestBody UserCreateDTO userUpdateDTO) { UserDTO updatedUser = userService.updateUser(id, userUpdateDTO); if (updatedUser != null) { return ResponseEntity.ok(updatedUser); } return ResponseEntity.notFound().build(); } // 删除用户 @DeleteMapping(\u0026#34;/{id}\u0026#34;) public ResponseEntity\u0026lt;Void\u0026gt; deleteUser(@PathVariable Integer id) { boolean deleted = userService.deleteUser(id); if (deleted) { return ResponseEntity.noContent().build(); } return ResponseEntity.notFound().build(); } } 问题汇总 整合 mybatis-plus 时需注意 springboot3 应引入对应的 boot3 版本，学习网站上的 boot4 并非和他说一样 springboot3.5 后面用 lombok 可能会导致通信时字段名大小写不匹配从而出现空赋值，如果有 validation 检验的话，会直接被拦截,该接口直接就是不会执行，在调试时可以发现接口处断点是禁止的白色符号，代表该接口未被调用，可以通过此排查问题 ","date":"2025-10-30T17:15:19+08:00","permalink":"https://axppk.github.io/p/springboot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/","title":"SpringBoot学习之路"},{"content":"前言 箱子属于硬表面，没用做贴图，用的全是程序化和网上下的素材，能省则省这一块。\n主要想锻炼下打光，并且保持建模手感。\n没有从头开始记录的必要直接展示成品。\n引用素材如下\n源石模型\n子弹模型\n成品 未处理 LOGO 前的第一版。 初步渲染 还是有明显区别的，没有加上周围那一圈失焦炫光的样子（合成器中的色散节点），因为调了自带的聚焦值，可能有些模糊，想更精细应该去 PS 中再精修一下，这里是直出图。 添加镜头畸变版本 添加摆件版 添加添加镜头畸变版 4K 渲染 添加镜头畸变版 4K 渲染修改材质一版 最终版 总结 材质基本用的程序化材质，网上下了部分划痕贴图 最后的粒子效果貌似有些问题，渲染出来粒子会明显卡顿，调了噪波阈值为 0.01 有轻微改善，预览和 EV 渲染器不会有问题，渲染的话图片序列和 MP4 均会有问题。 总之效果还行吧，算是个入门练习，后续可以继续优化。 参考图 游戏内截图 ","date":"2025-10-11T16:29:16+08:00","image":"https://axppk.github.io/p/%E6%98%8E%E6%97%A5%E6%96%B9%E8%88%9F%E8%81%94%E5%8A%A8%E7%AE%B1%E5%AD%90%E5%BB%BA%E6%A8%A1%E6%89%93%E5%85%89%E7%BB%83%E4%B9%A0/img/CY%E5%87%BA%E5%9B%BE1024+0.1%E5%99%AA%E6%B3%A2+GI_hu_ebc412134bb7a277.png","permalink":"https://axppk.github.io/p/%E6%98%8E%E6%97%A5%E6%96%B9%E8%88%9F%E8%81%94%E5%8A%A8%E7%AE%B1%E5%AD%90%E5%BB%BA%E6%A8%A1%E6%89%93%E5%85%89%E7%BB%83%E4%B9%A0/","title":"明日方舟联动箱子建模打光练习"},{"content":"前言 记录一下复刻过程，有机会后续做个 3d 的出来。\n素材都是直接扒的游戏的，网上有人做出来解密脚本了，直接解密用 AssetStudio 导出就行了。\n少扒了几个素材，后期用 ps 抠一下。\n先写大致思路，全部实现后填充细节。\n过程 前期素材搭建 底座，一切都没有的时候。 基本摆好 这里的水果一开始想全部摆好的，但是发现橙子的不太一样，只能是用常规的方法，一个显示另一个隐藏。 描边效果实现 描边，少前的描边居然是素材实现的，通过脚本控制显示即可。\n一开始用的 OnPointerEnter 和 OnPointerExit 实现（虽然 0 引用，脚本上还提示被拦截，但实际上系统会自己调用，这就是 unity 自带的接口），但是部分素材有交叉，有些小 bug，只能是用常规的 Update 每帧检测鼠标悬停物体了，性能方面有些影响。\n补充一下，UI 的射线检测可以直接用 raycast，不需要 collider（虽然有 collider 2d），但 3d 射线检测才需要。\nUI 射线检测一定要注意遮挡关系（没用的关掉它的 image 下的光线投射目标），可以新开简单场景测试脚本。代码如下 点击动效实现 明天再做，正在思考要不要塞到描边里，毕竟已经在描边脚本中获取了那些可被点击的物体了。\n塞描边里了。\n实现如下：\n同样的建表拿物体，只不过不是悬停而是点击\n播放逻辑，用的关启动画状态机实现（手动关启动画会重置，代码控制不会重置，所以需要 Fanimator.Play(\u0026ldquo;Click Animation\u0026rdquo;, -1, 0f); animator.Play(\u0026ldquo;Click Animation\u0026rdquo;, -1, 0f); 实现每次都从头开始） 用协程控制播放，因为要传参，所以不用 invoke（） 应该没拼错吧 由于是统一动画，所以对缩放做了些妥协，用父级控制缩放，虽然有点麻烦，但是有效。 最后挂载界面，发现如果手动删除组里数据，会导致显示出错，实际没事，运行就好了。 最后效果展示（左下动画应该是上下震动，后面独立改一下） 游戏核心提示框实现 核心提示框，有一些小的动效，游戏的核心玩法在这里体现，所以核心脚本挂载在这里。 判定的话涉及恢复和点击物体的判定\u0026mdash;-这里是早期的简单写法 忘了截图记录了，只记录了每天的最后成果，所以有时间直接贴代码分析吧。 每天成果 代码解释 描边和点击动画 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.UI; using UnityEngine.EventSystems; using System.Linq; public class outline : MonoBehaviour { [System.Serializable] public class ObjectOutlinePair { public GameObject targetObject; // UI 图像 public GameObject outlineObject; // 轮廓图像 } public Animator AClick; // 点击时播放的动画的状态机(这里好像不是单纯的animator controller) public Animator BClick; public List\u0026lt;ObjectOutlinePair\u0026gt; objectOutlineList = new List\u0026lt;ObjectOutlinePair\u0026gt;(); private Dictionary\u0026lt;GameObject, GameObject\u0026gt; outlineDictionary = new Dictionary\u0026lt;GameObject, GameObject\u0026gt;(); private GraphicRaycaster raycaster; private EventSystem eventSystem; private GameObject lastHoveredObject; private GameObject currentlyDisplayedOutline; private Coroutine currentAnimationCoroutine; string[] excludedNames = { \u0026#34;S1\u0026#34;, \u0026#34;S2\u0026#34;, \u0026#34;S3\u0026#34;, \u0026#34;S4\u0026#34;, \u0026#34;SS1\u0026#34;, \u0026#34;SS2\u0026#34;, \u0026#34;SS3\u0026#34;, \u0026#34;SS4\u0026#34; }; void Start() { // 获取必要的组件 raycaster = GetComponent\u0026lt;GraphicRaycaster\u0026gt;(); eventSystem = GetComponent\u0026lt;EventSystem\u0026gt;(); if (raycaster == null) raycaster = FindObjectOfType\u0026lt;GraphicRaycaster\u0026gt;(); if (eventSystem == null) eventSystem = FindObjectOfType\u0026lt;EventSystem\u0026gt;(); // 初始化字典 foreach (var pair in objectOutlineList) { if (pair.targetObject != null \u0026amp;\u0026amp; pair.outlineObject != null) { outlineDictionary[pair.targetObject] = pair.outlineObject; pair.outlineObject.SetActive(false); // 初始时隐藏所有轮廓 // 确保目标对象有Raycast Target启用 Image img = pair.targetObject.GetComponent\u0026lt;Image\u0026gt;(); if (img != null) img.raycastTarget = true; } // 添加Animator组件（如果还没有） if (AClick != null \u0026amp;\u0026amp; pair.outlineObject.GetComponent\u0026lt;Animator\u0026gt;() == null) { pair.outlineObject.AddComponent\u0026lt;Animator\u0026gt;(); Addanimation(pair.outlineObject); /* Debug.Log(\u0026#34;已为\u0026#34; + pair.outlineObject.name + \u0026#34;添加动画控制器\u0026#34;);*/ } // 添加Animator组件（如果还没有） if (AClick != null \u0026amp;\u0026amp; pair.targetObject.GetComponent\u0026lt;Animator\u0026gt;() == null) { pair.targetObject.AddComponent\u0026lt;Animator\u0026gt;(); //复制参考的状态机的值. Addanimation(pair.targetObject); /* Debug.Log(\u0026#34;已为\u0026#34; + pair.targetObject.name + \u0026#34;添加动画控制器\u0026#34;);*/ } pair.targetObject.GetComponent\u0026lt;Animator\u0026gt;().enabled = false; pair.outlineObject.GetComponent\u0026lt;Animator\u0026gt;().enabled = false; } } void Update() { // 每帧检测鼠标悬停 CheckHover(); // 检测鼠标点击 if (Input.GetMouseButtonDown(0)) // 0 表示左键点击 { CheckClick(); } } void CheckHover() { // 创建指针事件数据 PointerEventData pointerData = new PointerEventData(eventSystem); pointerData.position = Input.mousePosition; // 射线检测结果列表 List\u0026lt;RaycastResult\u0026gt; results = new List\u0026lt;RaycastResult\u0026gt;(); // 执行射线检测 raycaster.Raycast(pointerData, results); GameObject currentlyHoveredObject = null; // 查找第一个在字典中的对象 foreach (var result in results) { if (outlineDictionary.ContainsKey(result.gameObject)) { currentlyHoveredObject = result.gameObject; break; } } // 如果悬停的对象发生了变化 if (currentlyHoveredObject != lastHoveredObject) { // 隐藏之前显示的轮廓 if (currentlyDisplayedOutline != null) { currentlyDisplayedOutline.SetActive(false); //确保每次都是以（1，1，1）开始点击动画的变化,还有协程意外终止导致的状态机没有关闭 currentlyDisplayedOutline.transform.localScale = new Vector3(1f, 1f, 1f); currentlyDisplayedOutline.GetComponent\u0026lt;Animator\u0026gt;().enabled=false; currentlyDisplayedOutline = null; } // 如果悬停在新对象上，显示其轮廓 if (currentlyHoveredObject != null \u0026amp;\u0026amp; outlineDictionary.TryGetValue(currentlyHoveredObject, out GameObject outlineToShow)) { outlineToShow.SetActive(true); currentlyDisplayedOutline = outlineToShow; Debug.Log(\u0026#34;鼠标悬停在: \u0026#34; + currentlyHoveredObject.name); } // 更新最后悬停的对象 lastHoveredObject = currentlyHoveredObject; } } void CheckClick() { // 创建指针事件数据 PointerEventData pointerData = new PointerEventData(eventSystem); pointerData.position = Input.mousePosition; // 射线检测结果列表 List\u0026lt;RaycastResult\u0026gt; results = new List\u0026lt;RaycastResult\u0026gt;(); // 执行射线检测 raycaster.Raycast(pointerData, results); GameObject currentlyClickedObject = null; // 查找第一个在字典中的对象 foreach (var result in results) { if (outlineDictionary.ContainsKey(result.gameObject)) { currentlyClickedObject = result.gameObject; break; } } // 获取对应的ObjectOutlinePair if (outlineDictionary.TryGetValue(currentlyClickedObject, out GameObject ClickToShow)) { // 播放点击动画 PlayClickAnimation(currentlyClickedObject,ClickToShow); Debug.Log(\u0026#34;点击了: \u0026#34; + currentlyClickedObject.name); } } void PlayClickAnimation(GameObject currentlyClickedObject,GameObject ClickToShow) { Animator Fanimator = currentlyClickedObject.GetComponent\u0026lt;Animator\u0026gt;(); Animator animator = ClickToShow.GetComponent\u0026lt;Animator\u0026gt;(); if (animator != null) { // 播放动画 Fanimator.enabled = true; animator.enabled = true; Fanimator.Play(\u0026#34;Click Animation\u0026#34;, -1, 0f); animator.Play(\u0026#34;Click Animation\u0026#34;, -1, 0f); if (currentAnimationCoroutine != null) { StopCoroutine(currentAnimationCoroutine); Debug.Log(\u0026#34;已结束上一个协程\u0026#34;); // 重置前一个动画对象的状态 } Debug.Log(currentAnimationCoroutine); // 启动协程实现延迟调用 currentAnimationCoroutine = StartCoroutine(DisableAnimatorsAfterDelay(animator.GetCurrentAnimatorStateInfo(0).length, Fanimator, animator)); } else { Debug.LogWarning($\u0026#34;物体 {ClickToShow.name} 没有Animator组件，无法播放动画\u0026#34;); } } // 协程方法接收参数 private IEnumerator DisableAnimatorsAfterDelay(float delay, Animator anim1, Animator anim2) { yield return null; yield return new WaitForSeconds(delay); anim1.enabled = false; anim2.enabled = false; currentAnimationCoroutine = null; Debug.Log(\u0026#34;动画长度\u0026#34; + delay + \u0026#34;动画播放完毕，已禁用Animator组件\u0026#34;); } void Addanimation(GameObject selectedobject) { if (excludedNames.Contains(selectedobject.name) \u0026amp;\u0026amp; BClick != null) { selectedobject.GetComponent\u0026lt;Animator\u0026gt;().runtimeAnimatorController = BClick.runtimeAnimatorController; } else { selectedobject.GetComponent\u0026lt;Animator\u0026gt;().runtimeAnimatorController = AClick.runtimeAnimatorController; Debug.Log(\u0026#34;特殊动画BClick未部署\u0026#34;); } } } 效果 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 void Start() { // 获取必要的组件 raycaster = GetComponent\u0026lt;GraphicRaycaster\u0026gt;(); eventSystem = GetComponent\u0026lt;EventSystem\u0026gt;(); if (raycaster == null) raycaster = FindObjectOfType\u0026lt;GraphicRaycaster\u0026gt;(); if (eventSystem == null) eventSystem = FindObjectOfType\u0026lt;EventSystem\u0026gt;(); // 初始化字典 foreach (var pair in objectOutlineList) { if (pair.targetObject != null \u0026amp;\u0026amp; pair.outlineObject != null) { outlineDictionary[pair.targetObject] = pair.outlineObject; pair.outlineObject.SetActive(false); // 初始时隐藏所有轮廓 // 确保目标对象有Raycast Target启用 Image img = pair.targetObject.GetComponent\u0026lt;Image\u0026gt;(); if (img != null) img.raycastTarget = true; } // 添加Animator组件（如果还没有） if (AClick != null \u0026amp;\u0026amp; pair.outlineObject.GetComponent\u0026lt;Animator\u0026gt;() == null) { pair.outlineObject.AddComponent\u0026lt;Animator\u0026gt;(); Addanimation(pair.outlineObject); /* Debug.Log(\u0026#34;已为\u0026#34; + pair.outlineObject.name + \u0026#34;添加动画控制器\u0026#34;);*/ } // 添加Animator组件（如果还没有） if (AClick != null \u0026amp;\u0026amp; pair.targetObject.GetComponent\u0026lt;Animator\u0026gt;() == null) { pair.targetObject.AddComponent\u0026lt;Animator\u0026gt;(); //复制参考的状态机的值. Addanimation(pair.targetObject); /* Debug.Log(\u0026#34;已为\u0026#34; + pair.targetObject.name + \u0026#34;添加动画控制器\u0026#34;);*/ } pair.targetObject.GetComponent\u0026lt;Animator\u0026gt;().enabled = false; pair.outlineObject.GetComponent\u0026lt;Animator\u0026gt;().enabled = false; } } 首先开头的定义变量不解释\n该部分为初始化 Ui 的射线检测部件，顺便把物体和对应的轮廓初始化，以及实现点击弹性动画。\n思路是轮廓用图片的显示与否来实现，点击弹性动画由单一的缩放值控制，复制一个 animator 组件给所有物体实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 void CheckHover() { // 创建指针事件数据 PointerEventData pointerData = new PointerEventData(eventSystem); pointerData.position = Input.mousePosition; // 射线检测结果列表 List\u0026lt;RaycastResult\u0026gt; results = new List\u0026lt;RaycastResult\u0026gt;(); // 执行射线检测 raycaster.Raycast(pointerData, results); GameObject currentlyHoveredObject = null; // 查找第一个在字典中的对象 foreach (var result in results) { if (outlineDictionary.ContainsKey(result.gameObject)) { currentlyHoveredObject = result.gameObject; break; } } // 如果悬停的对象发生了变化 if (currentlyHoveredObject != lastHoveredObject) { // 隐藏之前显示的轮廓 if (currentlyDisplayedOutline != null) { currentlyDisplayedOutline.SetActive(false); //确保每次都是以（1，1，1）开始点击动画的变化,还有协程意外终止导致的状态机没有关闭 currentlyDisplayedOutline.transform.localScale = new Vector3(1f, 1f, 1f); currentlyDisplayedOutline.GetComponent\u0026lt;Animator\u0026gt;().enabled=false; currentlyDisplayedOutline = null; } // 如果悬停在新对象上，显示其轮廓 if (currentlyHoveredObject != null \u0026amp;\u0026amp; outlineDictionary.TryGetValue(currentlyHoveredObject, out GameObject outlineToShow)) { outlineToShow.SetActive(true); currentlyDisplayedOutline = outlineToShow; Debug.Log(\u0026#34;鼠标悬停在: \u0026#34; + currentlyHoveredObject.name); } // 更新最后悬停的对象 lastHoveredObject = currentlyHoveredObject; } } update 不解释，只是检测下是否点击\n该部分为鼠标悬停检测，主要是获取鼠标位置，然后执行射线检测，找到第一个在轮廓字典中的物体，然后显示其轮廓，并隐藏之前显示的轮廓。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 void CheckClick() { // 创建指针事件数据 PointerEventData pointerData = new PointerEventData(eventSystem); pointerData.position = Input.mousePosition; // 射线检测结果列表 List\u0026lt;RaycastResult\u0026gt; results = new List\u0026lt;RaycastResult\u0026gt;(); // 执行射线检测 raycaster.Raycast(pointerData, results); GameObject currentlyClickedObject = null; // 查找第一个在字典中的对象 foreach (var result in results) { if (outlineDictionary.ContainsKey(result.gameObject)) { currentlyClickedObject = result.gameObject; break; } } // 获取对应的ObjectOutlinePair if (outlineDictionary.TryGetValue(currentlyClickedObject, out GameObject ClickToShow)) { // 播放点击动画 PlayClickAnimation(currentlyClickedObject,ClickToShow); Debug.Log(\u0026#34;点击了: \u0026#34; + currentlyClickedObject.name); } } 其实是悬停的翻版，因为没有再回头优化，现在看这玩意都多余分出来。\n点击动画的实现，主要是获取点击的物体，然后获取对应的轮廓，然后播放动画，这里的动画是由 animator 组件控制的，所以需要先添加 animator 组件，然后复制参考的状态机的值，然后播放动画，最后启动一个协程实现延迟调用，等待动画播放完毕，然后禁用 animator 组件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 void PlayClickAnimation(GameObject currentlyClickedObject,GameObject ClickToShow) { Animator Fanimator = currentlyClickedObject.GetComponent\u0026lt;Animator\u0026gt;(); Animator animator = ClickToShow.GetComponent\u0026lt;Animator\u0026gt;(); if (animator != null) { // 播放动画 Fanimator.enabled = true; animator.enabled = true; Fanimator.Play(\u0026#34;Click Animation\u0026#34;, -1, 0f); animator.Play(\u0026#34;Click Animation\u0026#34;, -1, 0f); if (currentAnimationCoroutine != null) { StopCoroutine(currentAnimationCoroutine); Debug.Log(\u0026#34;已结束上一个协程\u0026#34;); // 重置前一个动画对象的状态 } Debug.Log(currentAnimationCoroutine); // 启动协程实现延迟调用 currentAnimationCoroutine = StartCoroutine(DisableAnimatorsAfterDelay(animator.GetCurrentAnimatorStateInfo(0).length, Fanimator, animator)); } else { Debug.LogWarning($\u0026#34;物体 {ClickToShow.name} 没有Animator组件，无法播放动画\u0026#34;); } } 播放动画真正实现的地方，获取本体和轮廓的 animator 组件，由于运行起来之后播放动画状态在启用和禁用之间不会重置，所以要手动在播放动画前设置初始状态，最后通过协程方式激活\n剩下的比较简单，不解释了。\n游戏核心玩法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 using UnityEngine; using UnityEngine.UI; using System; using System.Collections.Generic; using UnityEngine.EventSystems; using System.Linq; using System.Collections; public class ImageCombinationDisplay : MonoBehaviour { [Header(\u0026#34;可点击物体\u0026#34;)] [Tooltip(\u0026#34;按顺序排列可点击物体序号\u0026#34;)] public GameObject[] targetObject; // UI 图像 [Header(\u0026#34;图片资源\u0026#34;)] [Tooltip(\u0026#34;按顺序分配对应的图片\u0026#34;)] public Sprite[] numberSprites = new Sprite[8]; [Header(\u0026#34;UI图片组件\u0026#34;)] [Tooltip(\u0026#34;用于显示组合图片的5个UI Image组件\u0026#34;)] public Image[] displayImages = new Image[5]; [Header(\u0026#34;预设组合\u0026#34;)] [Tooltip(\u0026#34;预设的五位数组合列表\u0026#34;)] public string[] presetCombinations = new string[] { \u0026#34;0,1,10,10\u0026#34; }; [Header(\u0026#34;预设蛋糕组合\u0026#34;)] [Tooltip(\u0026#34;预设的蛋糕组合列表\u0026#34;)] public string[] cakeCombinations = new string[] { \u0026#34;17,18,19\u0026#34; }; [Header(\u0026#34;提示用物体\u0026#34;)] [Tooltip(\u0026#34;按顺序排列控制提示\u0026#34;)] public GameObject[] tipObject; // 提示 [Header(\u0026#34;动态提示用指针\u0026#34;)] [Tooltip(\u0026#34;按顺序排列控制提示\u0026#34;)] public GameObject[] DtipObject; // 提示 [Header(\u0026#34;动态提示用物体\u0026#34;)] [Tooltip(\u0026#34;按顺序排列控制提示\u0026#34;)] public GameObject[] DDtipObject; // 提示 [Header(\u0026#34;三次判断提示用物体\u0026#34;)] [Tooltip(\u0026#34;三次判断控制提示\u0026#34;)] public GameObject[] threeObject; // 提示 [Header(\u0026#34;三次判断加载提示用物体\u0026#34;)] [Tooltip(\u0026#34;三次判断加载提示\u0026#34;)] public GameObject[] threeloadObject; // 提示 [Header(\u0026#34;测试用\u0026#34;)] [Tooltip(\u0026#34;在编辑器中测试的组合字符串\u0026#34;)] public string testCombination = \u0026#34;21356\u0026#34;; // UI射线检测必需的组件 private GraphicRaycaster raycaster; private EventSystem eventSystem; // 存储解析后的数字数组 private int[] currentDigitArray; //特殊三次判定的物品序号 private int[] excludedObject = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 16, 17, 18, 19}; //点击帮他人恢复次数 private int[] OtherexcludedObject = { 22,23,24,25,26,27,28}; //点击自身恢复次数 private int[] SpecialexcludedObject = { 1,2,3,4,5,17,18,19}; // 存储每个物品的剩余点击次数的字典 private Dictionary\u0026lt;int, int\u0026gt; clickCounts = new Dictionary\u0026lt;int, int\u0026gt;(); // 记录玩家点击的顺序 private List\u0026lt;int\u0026gt; playerInputSequence = new List\u0026lt;int\u0026gt;(); // 当前点击的次数 private int currentClickedIndex = 0; // 当前点击的正确数 private int currentExpectedIndex = 0; //当前点击的错误数 private int currentErrorIndex = 0; // 记录上一次是否执行了蛋糕组合函数 private bool lastWasCakeCombination = false; //记录当前消逝协程动画数（协程具有延后性，像描边那里根据单一值跟踪其实没有用） private Dictionary\u0026lt;int, int\u0026gt; AnimateUICount = new Dictionary\u0026lt;int, int\u0026gt;(); void Start() { // 初始化点击次数 InitializeClickCounts(); // 获取必要的组件（鼠标点击用的射线检测） raycaster = GetComponent\u0026lt;GraphicRaycaster\u0026gt;(); eventSystem = GetComponent\u0026lt;EventSystem\u0026gt;(); if (raycaster == null) raycaster = FindObjectOfType\u0026lt;GraphicRaycaster\u0026gt;(); if (eventSystem == null) eventSystem = FindObjectOfType\u0026lt;EventSystem\u0026gt;(); // 如果设置了测试组合，自动应用 if (!string.IsNullOrEmpty(testCombination)) { SetImageCombination(testCombination); } else { SelectRandomCombination(); } } void Update() { // 检测鼠标点击 if (Input.GetMouseButtonDown(0)) // 0 表示左键点击 { CheckClick(); } //我也不想用每帧判断，会浪费性能，但是第一时间又没想好用哪个最简单实现蛋糕自动判断 if(lastWasCakeCombination \u0026amp;\u0026amp; currentExpectedIndex \u0026gt;= currentDigitArray.Length) { ProcessObjectClick(20); } } public void SelectRandomCombination() { if (presetCombinations == null || presetCombinations.Length == 0) { Debug.LogError(\u0026#34;预设组合列表为空!\u0026#34;); return; } // 随机选择一个组合 int randomIndex = UnityEngine.Random.Range(0, presetCombinations.Length); string selectedCombination = presetCombinations[randomIndex]; // 应用选中的组合 SetImageCombination(selectedCombination); } public void SelectRandomcakeCombination() { if (cakeCombinations == null || cakeCombinations.Length == 0) { Debug.LogError(\u0026#34;预设组合列表为空!\u0026#34;); return; } // 随机选择一个组合 int randomIndex = UnityEngine.Random.Range(0, cakeCombinations.Length); string selectedCombination = cakeCombinations[randomIndex]; // 应用选中的组合 SetImageCombination(selectedCombination); } /// \u0026lt;summary\u0026gt; /// 设置图片组合 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;combination\u0026#34;\u0026gt;5位数字字符串，每位数字0-7\u0026lt;/param\u0026gt; public void SetImageCombination(string combination) { // 验证输入 if (string.IsNullOrEmpty(combination)) { Debug.LogError(\u0026#34;组合不能为空!\u0026#34;); return; } // 检查所有图片资源是否已分配 for (int i = 0; i \u0026lt; numberSprites.Length; i++) { if (numberSprites[i] == null) { Debug.LogError($\u0026#34;数字 {i} 对应的图片未分配!\u0026#34;); return; } } // 检查所有UI Image组件是否已分配 for (int i = 0; i \u0026lt; displayImages.Length; i++) { if (displayImages[i] == null) { Debug.LogError($\u0026#34;显示图片 {i} 的UI组件未分配!\u0026#34;); return; } } //应用前关掉全部材料图 for (int i = 0; i \u0026lt; 5;i++) { displayImages[i].gameObject.SetActive(false); } // 解析组合字符串 string[] digitStrings = combination.Split(\u0026#39;,\u0026#39;); currentDigitArray = new int[digitStrings.Length]; for (int i = 0; i \u0026lt; digitStrings.Length; i++) { if (!int.TryParse(digitStrings[i], out currentDigitArray[i])) { Debug.LogError($\u0026#34;无法解析数字: {digitStrings[i]}\u0026#34;); return; } Debug.Log($\u0026#34;当前解析数字: {currentDigitArray[i]}\u0026#34;); } // 应用组合 for (int i = 0; i \u0026lt; currentDigitArray.Length; i++) { displayImages[i].gameObject.SetActive(true); displayImages[i].sprite = numberSprites[currentDigitArray[i]]; } Debug.Log($\u0026#34;成功设置图片组合: {combination}\u0026#34;); // 重置游戏状态 ResetGameState(); } void CheckClick() { // 创建指针事件数据 PointerEventData pointerData = new PointerEventData(eventSystem); pointerData.position = Input.mousePosition; // 射线检测结果列表 List\u0026lt;RaycastResult\u0026gt; results = new List\u0026lt;RaycastResult\u0026gt;(); // 执行射线检测 raycaster.Raycast(pointerData, results); // 查找点击到的对象是否在targetObject数组中 foreach (var result in results) { int objectIndex = Array.IndexOf(targetObject, result.gameObject); if (objectIndex \u0026gt;= 0) // 找到了点击的对象 { Debug.Log($\u0026#34;点击了对象: {result.gameObject.name}, 索引: {objectIndex}\u0026#34;); //独立的，如果是这两个功能更键直接在这里单独传-----因为下面传参是写在判断逻辑里，判断逻辑实现了0次数排除 if (objectIndex == 20 || objectIndex == 21) { //传点击序号给最终确认脚本 Finalconfirmation.TriggerObjectClicked(objectIndex); } // 处理点击逻辑 ProcessObjectClick(objectIndex); break; } } } /// \u0026lt;summary\u0026gt; /// 处理对象点击逻辑 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;objectIndex\u0026#34;\u0026gt;被点击对象的索引\u0026lt;/param\u0026gt; void ProcessObjectClick(int objectIndex) { // 特殊功能键处理 if (objectIndex == 20) // 完成键 { // 检查是否完成整个序列 if (currentExpectedIndex \u0026gt;= currentDigitArray.Length) { Debug.Log(\u0026#34;恭喜! 顺序完全正确!\u0026#34;); // 隐藏所有动态提示 for (int i = 0; i \u0026lt; DtipObject.Length; i++) { if (i \u0026lt; DtipObject.Length) DtipObject[i].SetActive(false); if (i \u0026lt; DDtipObject.Length) DDtipObject[i].SetActive(false); } // 下一个组合 if (lastWasCakeCombination) { // 上次执行了蛋糕组合，本次必须执行普通组合 SelectRandomCombination(); lastWasCakeCombination = false; } else { // 50%概率随机选择 float randomValue = UnityEngine.Random.value; // 生成0-1之间的随机数 if (randomValue \u0026lt; 0.5f) { // 50%概率执行蛋糕组合 SelectRandomcakeCombination(); lastWasCakeCombination = true; Debug.Log(\u0026#34;此次为蛋糕组合\u0026#34;); } else { // 50%概率执行普通组合 SelectRandomCombination(); lastWasCakeCombination = false; } } } else { Debug.Log(\u0026#34;尚未完成当前组合!\u0026#34;); } return; } if (objectIndex == 21) // 重置键 { ResetGameState(); return; } // 记录玩家点击 playerInputSequence.Add(objectIndex); // 追踪点击次数 currentClickedIndex++; if (excludedObject.Contains(objectIndex) || OtherexcludedObject.Contains(objectIndex)) { Debug.Log(\u0026#34;当前点击为特殊物品，序号\u0026#34; + objectIndex); ParticularJudgment(objectIndex); } else { Judgment(objectIndex); } Debug.Log($\u0026#34;当前点击次数为{currentClickedIndex}，当前正确次数为{currentExpectedIndex}，当前错误次数为{currentErrorIndex}\u0026#34;); } // 初始化点击次数---用于追踪消逝动画执行次数和三次判定 void InitializeClickCounts() { foreach (int id in excludedObject) { clickCounts[id] = 3; // 初始3次点击机会 } for (int i = 15; i \u0026lt; 20; i++) { AnimateUICount[i] = 0;//初始每个都0个协程动画 } //咖啡液 AnimateUICount[10] = 0; } // 加载动画---点击他人恢复次数 public void StartSequence(int clickCountsobject,int loadobject,int n,bool YNthree) { // 激活threeloadObject并播放动画 threeloadObject[loadobject].SetActive(true); // 获取动画组件并播放 Animator animator = threeloadObject[loadobject].GetComponent\u0026lt;Animator\u0026gt;(); if (animator != null) { animator.SetTrigger(\u0026#34;Load Animation\u0026#34;); // 启动协程等待动画完成 StartCoroutine(WaitForAnimationFinish(animator,clickCountsobject,loadobject, n, YNthree)); } else { Debug.LogError( threeloadObject[loadobject].name + \u0026#34;上没有Animator组件！\u0026#34;); } } // 协程：等待动画播放完成----点击他人供应的 IEnumerator WaitForAnimationFinish(Animator animator, int clickCountsobject, int loadobject, int n, bool YNthree) { // 等待动画开始播放 yield return new WaitForEndOfFrame(); // 获取当前播放的动画状态信息（层索引默认为0） AnimatorStateInfo stateInfo = animator.GetCurrentAnimatorStateInfo(0); // 等待动画播放完成（normalizedTime \u0026gt;= 1表示播放完毕） yield return new WaitWhile(() =\u0026gt; animator.GetCurrentAnimatorStateInfo(0).normalizedTime \u0026lt; 1); // 动画播放完成后执行的操作 ExecuteAfterAnimation(clickCountsobject,loadobject, n, YNthree); } // 动画完成后执行：激活目标对象并禁用源对象 void ExecuteAfterAnimation(int clickCountsobject, int loadobject, int n,bool YNthree) { //重置次数 clickCounts[clickCountsobject] = 3; if (YNthree) { // 激活threeObject for (int i = 0; i \u0026lt; 3; i++) { int index = i + 3 * n; if (threeObject[index] != null) { threeObject[index].SetActive(true); } else { Debug.LogWarning($\u0026#34;threeObject[{index}] 未赋值！\u0026#34;); } } } else { threeObject[2 + 3 * n].SetActive(true); } //靠他人恢复的重置 if (clickCountsobject == 10 || clickCountsobject == 15 || clickCountsobject == 16) { //重置消逝协程动画数 AnimateUICount[clickCountsobject] = 0; } // 禁用threeloadObject threeloadObject[loadobject].SetActive(false); } // 协程：等待动画播放完成----为有特殊的加载动画的物体服务（点击自身供应的） IEnumerator LittleWaitForAnimationFinish(Animator animator, int objectIndex) { // 等待动画开始播放 yield return new WaitForEndOfFrame(); // 获取当前播放的动画状态信息（层索引默认为0） AnimatorStateInfo stateInfo = animator.GetCurrentAnimatorStateInfo(0); // 等待动画播放完成（normalizedTime \u0026gt;= 1表示播放完毕） yield return new WaitWhile(() =\u0026gt; animator.GetCurrentAnimatorStateInfo(0).normalizedTime \u0026lt; 1); // 动画播放完成后执行的操作 clickCounts[objectIndex] = 3; if (objectIndex \u0026lt; 6) { // 取消激活threeloadObject threeloadObject[objectIndex].SetActive(false); } else { //重置消逝协程动画数 AnimateUICount[objectIndex] = 0; } } //提示版的正负判断逻辑 void Judgment(int objectIndex) { // 更新动态提示 UpdateDynamicTips(); //传点击序号给最终确认脚本 Finalconfirmation.TriggerObjectClicked(objectIndex); // 检查是否正确 if (currentExpectedIndex \u0026lt; currentDigitArray.Length \u0026amp;\u0026amp; objectIndex == currentDigitArray[currentErrorIndex + currentExpectedIndex]) { // 正确提示显示 - 确保不越界 if (currentExpectedIndex \u0026lt; currentDigitArray.Length) { tipObject[currentErrorIndex + currentExpectedIndex].SetActive(true); } // 正确点击 currentExpectedIndex++; Debug.Log($\u0026#34;正确! 当前进度: {currentExpectedIndex}/{currentDigitArray.Length}\u0026#34;); } else { // 错误点击提示 - 确保不越界 if (currentErrorIndex + currentExpectedIndex \u0026lt; currentDigitArray.Length) { tipObject[5 + currentErrorIndex + currentExpectedIndex].SetActive(true); } // 错误点击 currentErrorIndex++; Debug.Log(\u0026#34;点击错误显示位置为 \u0026#34; + (4 + currentClickedIndex - 1)); } } //有加载动画的恢复次数逻辑 void ParticularJudgment(int objectIndex) { //此处判断全是硬编码，没有换循环---器械 if (objectIndex == 22 \u0026amp;\u0026amp; AnimateUICount[objectIndex - 12] == 3) { //clickCounts，loadObject，3*n StartSequence(10,10,4, true); Debug.Log($\u0026#34; 咖啡液 点击次数已恢复\u0026#34;); return; } if (objectIndex == 27 \u0026amp;\u0026amp; AnimateUICount[objectIndex - 12] == 3) { //clickCounts，loadObject，3*n StartSequence(15, 11, 5, true); Debug.Log($\u0026#34; 芝士 点击次数已恢复\u0026#34;); return; } if (objectIndex == 28 \u0026amp;\u0026amp; AnimateUICount[objectIndex - 12] == 3) { //clickCounts，loadObject，3*n StartSequence(16, 0, 6, true); Debug.Log($\u0026#34; 坚果 点击次数已恢复\u0026#34;); return; } //此处判断全是硬编码，没有换循环---水果 if (objectIndex == 23) { //clickCounts，loadObject，2 + 3*n StartSequence(9, 9, 0, false); Debug.Log($\u0026#34; 蓝莓 点击次数已恢复\u0026#34;); return; } if (objectIndex == 24) { //clickCounts，loadObject，2 + 3*n StartSequence(8, 8, 1, false); Debug.Log($\u0026#34; 橙子 点击次数已恢复\u0026#34;); return; } if (objectIndex == 25) { //clickCounts，loadObject，2 + 3*n StartSequence(7, 7, 2, false); Debug.Log($\u0026#34; 草莓 点击次数已恢复\u0026#34;); return; } if (objectIndex == 26) { //clickCounts，loadObject，2 + 3*n StartSequence(6, 6, 3, false); Debug.Log($\u0026#34; 薄荷 点击次数已恢复\u0026#34;); return; } // 处理其他特殊物品----点击自身恢复次数 if (SpecialexcludedObject.Contains(objectIndex)) { if (clickCounts[objectIndex] == 0) { //提拉美苏 樱花蛋卷 草莓蛋糕 17 18 19 //n用来追踪组 int n = 7; for (int i = 17;i\u0026lt;20;i++) { if (objectIndex == i \u0026amp;\u0026amp; AnimateUICount[objectIndex] == 3) { for (int ii = 0; ii \u0026lt; 3; ii++) { threeObject[ii + 3 * n].SetActive(true); } StartCoroutine(LittleWaitForAnimationFinish(threeObject[3 * n].GetComponent\u0026lt;Animator\u0026gt;(), objectIndex)); n = 7; } n++; } // 水 牛奶 茶 椰汁 巧克力 1 2 3 4 5 for (int i = 1; i \u0026lt; 6; i++) { if (objectIndex == i) { threeObject[53 - 4 * i].SetActive(true); // 激活threeloadObject并播放动画 11 4 5 6 7 threeloadObject[objectIndex].SetActive(true); // 启动特殊协程等待动画完成 StartCoroutine(LittleWaitForAnimationFinish(threeloadObject[objectIndex].GetComponent\u0026lt;Animator\u0026gt;(),objectIndex)); } } Debug.Log($\u0026#34;特殊物品 {objectIndex} 点击次数重置为 3\u0026#34;); } else { if (currentErrorIndex + currentExpectedIndex != currentDigitArray.Length) { clickCounts[objectIndex]--; threeJudgement(objectIndex); Judgment(objectIndex); Debug.Log($\u0026#34;特殊物品 {objectIndex} 点击次数减1，剩余: {clickCounts[objectIndex]}\u0026#34;); } } } else { // 如果不是SpecialexcludedObject或OtherexcludedObject中的特殊物品，属于普通的三次物品直接进行判定即可---那些水果 if (currentErrorIndex + currentExpectedIndex != currentDigitArray.Length \u0026amp;\u0026amp; !OtherexcludedObject.Contains(objectIndex)) { if (clickCounts[objectIndex] \u0026gt; 0) { clickCounts[objectIndex]--; threeJudgement(objectIndex); Judgment(objectIndex); Debug.Log($\u0026#34;其他特殊物品 {objectIndex} 点击次数减1，剩余: {clickCounts[objectIndex]}\u0026#34;); } else { Debug.Log($\u0026#34;其他特殊物品 {objectIndex} 点击次数已为0，不再减少\u0026#34;); } } } } //消逝动画赋予逻辑 void threeJudgement(int objectIndex) { //咖啡液 排序有问题只能单领出来了---上面注册消逝协程动画数也是单领的 if (objectIndex == 10) { //消逝协程动画数 if (AnimateUICount[objectIndex] != 3) { StartCoroutine(AnimateUI(threeObject[clickCounts[objectIndex] + 12], objectIndex)); } } //n用来追踪组 int n = 0; //三个蛋糕和芝士，坚果 for (int i = 15; i \u0026lt; 20; i++) { if (objectIndex == i) { //消逝协程动画数 if (AnimateUICount[objectIndex] != 3) { StartCoroutine(AnimateUI(threeObject[clickCounts[objectIndex] + 15 + 3 * n],objectIndex)); } } n++; } //蓝莓 if (objectIndex == 9) { if (clickCounts[objectIndex] != 0) { threeObject[clickCounts[objectIndex]].SetActive(false); threeObject[clickCounts[objectIndex] - 1].SetActive(true); } else { threeObject[clickCounts[objectIndex]].SetActive(false); } } //橙子 if (objectIndex == 8) { if (clickCounts[objectIndex] != 0) { threeObject[clickCounts[objectIndex] + 3].SetActive(false); threeObject[clickCounts[objectIndex] - 1 + 3].SetActive(true); } else { threeObject[clickCounts[objectIndex] + 3].SetActive(false); } } //草莓 if (objectIndex == 7) { if (clickCounts[objectIndex] != 0) { threeObject[clickCounts[objectIndex] + 6].SetActive(false); threeObject[clickCounts[objectIndex] - 1 + 6].SetActive(true); } else { threeObject[clickCounts[objectIndex] + 6].SetActive(false); } } //薄荷 if (objectIndex == 6) { if (clickCounts[objectIndex] != 0) { threeObject[clickCounts[objectIndex] + 9].SetActive(false); threeObject[clickCounts[objectIndex] - 1 + 9].SetActive(true); } else { threeObject[clickCounts[objectIndex] + 9].SetActive(false); } } //巧克力 if (objectIndex == 5) { threeObject[clickCounts[objectIndex] + 31].SetActive(false); threeObject[clickCounts[objectIndex] - 1 + 31].SetActive(true); } //椰汁 if (objectIndex == 4) { threeObject[clickCounts[objectIndex] + 35].SetActive(false); threeObject[clickCounts[objectIndex] - 1 + 35].SetActive(true); } //茶 if (objectIndex == 3) { threeObject[clickCounts[objectIndex] + 39].SetActive(false); threeObject[clickCounts[objectIndex] - 1 + 39].SetActive(true); } //牛奶 if (objectIndex == 2) { threeObject[clickCounts[objectIndex] + 43].SetActive(false); threeObject[clickCounts[objectIndex] - 1 + 43].SetActive(true); } //水 if (objectIndex == 1) { threeObject[clickCounts[objectIndex] + 47].SetActive(false); threeObject[clickCounts[objectIndex] - 1 + 47].SetActive(true); } } //协程：消逝特效动画 IEnumerator AnimateUI(GameObject targetUI,int objectIndex) { // 获取RectTransform和CanvasGroup组件 RectTransform rectTransform = targetUI.GetComponent\u0026lt;RectTransform\u0026gt;(); CanvasGroup canvasGroup = targetUI.GetComponent\u0026lt;CanvasGroup\u0026gt;(); //没有canvasgroup自动加 if (canvasGroup == null) { canvasGroup = targetUI.AddComponent\u0026lt;CanvasGroup\u0026gt;(); } // 记录初始值 Vector2 startPosition = rectTransform.anchoredPosition; float startAlpha = canvasGroup.alpha; // 目标值 Vector2 targetPosition = startPosition + new Vector2(0, 70f); float targetAlpha = 0f; // 动画持续时间（可根据需要调整） float duration = 0.35f; float elapsed = 0f; // 线性插值 while (elapsed \u0026lt; duration) { elapsed += Time.deltaTime; float t = elapsed / duration; rectTransform.anchoredPosition = Vector2.Lerp(startPosition, targetPosition, t); canvasGroup.alpha = Mathf.Lerp(startAlpha, targetAlpha, t); yield return null; } // 恢复初始值 rectTransform.anchoredPosition = startPosition; canvasGroup.alpha = startAlpha; targetUI.SetActive(false); //消逝协程动画数自增----最高到3 AnimateUICount[objectIndex]++; } /// \u0026lt;summary\u0026gt; /// 更新动态提示 /// \u0026lt;/summary\u0026gt; void UpdateDynamicTips() { // 显示当前步骤的动态提示 - 确保不越界 int tipIndex = Mathf.Min(currentErrorIndex + currentExpectedIndex + 1, DtipObject.Length - 1); // 隐藏所有动态提示 if (tipIndex != currentDigitArray.Length) { for (int i = 0; i \u0026lt; DtipObject.Length; i++) { if (i \u0026lt; DtipObject.Length) DtipObject[i].SetActive(false); } for (int i = 0; i \u0026lt; DDtipObject.Length; i++) { if (i \u0026lt; DDtipObject.Length) DDtipObject[i].SetActive(false); } } if (tipIndex \u0026gt;= 0 \u0026amp;\u0026amp; tipIndex \u0026lt; DtipObject.Length \u0026amp;\u0026amp; tipIndex \u0026lt; currentDigitArray.Length) { DtipObject[tipIndex].SetActive(true); } if (tipIndex \u0026gt;= 0 \u0026amp;\u0026amp; tipIndex \u0026lt; DDtipObject.Length \u0026amp;\u0026amp; tipIndex \u0026lt; currentDigitArray.Length) { DDtipObject[tipIndex].SetActive(true); } } /// \u0026lt;summary\u0026gt; /// 重置游戏状态 /// \u0026lt;/summary\u0026gt; private void ResetGameState() { // 玩家点击序号顺序其实没啥用（本来想用来校准用，不过直接用正确数确认也行） playerInputSequence.Clear(); // 重置掉三个追踪数 currentExpectedIndex = 0; currentErrorIndex = 0; currentClickedIndex = 0; // 重置正确与错误提示显示 for (int i = 0; i \u0026lt; tipObject.Length; i++) { tipObject[i].SetActive(false); } // 全部重置指针，防止提前重置 for (int i = 0; i \u0026lt; DtipObject.Length; i++) { if (i \u0026lt; DtipObject.Length) DtipObject[i].SetActive(false); } for (int i = 0; i \u0026lt; DDtipObject.Length; i++) { if (i \u0026lt; DDtipObject.Length) DDtipObject[i].SetActive(false); } // 初始指针需要被显示 if (DtipObject.Length \u0026gt; 0) DtipObject[0].SetActive(true); if (DDtipObject.Length \u0026gt; 0) DDtipObject[0].SetActive(true); } } 这个就比较多了，我不想涉及太多脚本通信，能写一起的全写一起了，效果就是游戏做成的样子。由于缺少回头优化，所以很多地方还保留着我最开始的设想，比如多个 if 判断，还有大量的硬编码。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 public void SelectRandomCombination() { if (presetCombinations == null || presetCombinations.Length == 0) { Debug.LogError(\u0026#34;预设组合列表为空!\u0026#34;); return; } // 随机选择一个组合 int randomIndex = UnityEngine.Random.Range(0, presetCombinations.Length); string selectedCombination = presetCombinations[randomIndex]; // 应用选中的组合 SetImageCombination(selectedCombination); } public void SelectRandomcakeCombination() { if (cakeCombinations == null || cakeCombinations.Length == 0) { Debug.LogError(\u0026#34;预设组合列表为空!\u0026#34;); return; } // 随机选择一个组合 int randomIndex = UnityEngine.Random.Range(0, cakeCombinations.Length); string selectedCombination = cakeCombinations[randomIndex]; // 应用选中的组合 SetImageCombination(selectedCombination); } /// \u0026lt;summary\u0026gt; /// 设置图片组合 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;combination\u0026#34;\u0026gt;5位数字字符串，每位数字0-7\u0026lt;/param\u0026gt; public void SetImageCombination(string combination) { // 验证输入 if (string.IsNullOrEmpty(combination)) { Debug.LogError(\u0026#34;组合不能为空!\u0026#34;); return; } // 检查所有图片资源是否已分配 for (int i = 0; i \u0026lt; numberSprites.Length; i++) { if (numberSprites[i] == null) { Debug.LogError($\u0026#34;数字 {i} 对应的图片未分配!\u0026#34;); return; } } // 检查所有UI Image组件是否已分配 for (int i = 0; i \u0026lt; displayImages.Length; i++) { if (displayImages[i] == null) { Debug.LogError($\u0026#34;显示图片 {i} 的UI组件未分配!\u0026#34;); return; } } //应用前关掉全部材料图 for (int i = 0; i \u0026lt; 5;i++) { displayImages[i].gameObject.SetActive(false); } // 解析组合字符串 string[] digitStrings = combination.Split(\u0026#39;,\u0026#39;); currentDigitArray = new int[digitStrings.Length]; for (int i = 0; i \u0026lt; digitStrings.Length; i++) { if (!int.TryParse(digitStrings[i], out currentDigitArray[i])) { Debug.LogError($\u0026#34;无法解析数字: {digitStrings[i]}\u0026#34;); return; } Debug.Log($\u0026#34;当前解析数字: {currentDigitArray[i]}\u0026#34;); } // 应用组合 for (int i = 0; i \u0026lt; currentDigitArray.Length; i++) { displayImages[i].gameObject.SetActive(true); displayImages[i].sprite = numberSprites[currentDigitArray[i]]; } Debug.Log($\u0026#34;成功设置图片组合: {combination}\u0026#34;); // 重置游戏状态 ResetGameState(); } 提前设置好预设组合，随机选择预设组合，通过预设组合的数字对应图片资源，设置图片组合。\n提示版是一个重要的体现，他的组合并非固定，由于图片多于 10 个，起初我是用数组来表示，但是数组存在 010101 这样类似的情况会难以分辨，所以没法单纯的用数组来表示，所以我用了字符串来表示，然后通过英文逗号分割来解析。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 void CheckClick() { // 创建指针事件数据 PointerEventData pointerData = new PointerEventData(eventSystem); pointerData.position = Input.mousePosition; // 射线检测结果列表 List\u0026lt;RaycastResult\u0026gt; results = new List\u0026lt;RaycastResult\u0026gt;(); // 执行射线检测 raycaster.Raycast(pointerData, results); // 查找点击到的对象是否在targetObject数组中 foreach (var result in results) { int objectIndex = Array.IndexOf(targetObject, result.gameObject); if (objectIndex \u0026gt;= 0) // 找到了点击的对象 { Debug.Log($\u0026#34;点击了对象: {result.gameObject.name}, 索引: {objectIndex}\u0026#34;); //独立的，如果是这两个功能更键直接在这里单独传-----因为下面传参是写在判断逻辑里，判断逻辑实现了0次数排除 if (objectIndex == 20 || objectIndex == 21) { //传点击序号给最终确认脚本 Finalconfirmation.TriggerObjectClicked(objectIndex); } // 处理点击逻辑 ProcessObjectClick(objectIndex); break; } } } 同样的射线检测，中间涉及一个脚本通讯，这里 objectIndex == 20 || objectIndex == 21 是确认和删除键。\n这一层实现点击判断，通过点击的对象在组中的序号来作为根基，去实现我们想要的其他操作，分辨出点击的是哪个物体。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 /// \u0026lt;summary\u0026gt; /// 处理对象点击逻辑 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;objectIndex\u0026#34;\u0026gt;被点击对象的索引\u0026lt;/param\u0026gt; void ProcessObjectClick(int objectIndex) { // 特殊功能键处理 if (objectIndex == 20) // 完成键 { // 检查是否完成整个序列 if (currentExpectedIndex \u0026gt;= currentDigitArray.Length) { Debug.Log(\u0026#34;恭喜! 顺序完全正确!\u0026#34;); // 隐藏所有动态提示 for (int i = 0; i \u0026lt; DtipObject.Length; i++) { if (i \u0026lt; DtipObject.Length) DtipObject[i].SetActive(false); if (i \u0026lt; DDtipObject.Length) DDtipObject[i].SetActive(false); } // 下一个组合 if (lastWasCakeCombination) { // 上次执行了蛋糕组合，本次必须执行普通组合 SelectRandomCombination(); lastWasCakeCombination = false; } else { // 50%概率随机选择 float randomValue = UnityEngine.Random.value; // 生成0-1之间的随机数 if (randomValue \u0026lt; 0.5f) { // 50%概率执行蛋糕组合 SelectRandomcakeCombination(); lastWasCakeCombination = true; Debug.Log(\u0026#34;此次为蛋糕组合\u0026#34;); } else { // 50%概率执行普通组合 SelectRandomCombination(); lastWasCakeCombination = false; } } } else { Debug.Log(\u0026#34;尚未完成当前组合!\u0026#34;); } return; } if (objectIndex == 21) // 重置键 { ResetGameState(); return; } // 记录玩家点击 playerInputSequence.Add(objectIndex); // 追踪点击次数 currentClickedIndex++; if (excludedObject.Contains(objectIndex) || OtherexcludedObject.Contains(objectIndex)) { Debug.Log(\u0026#34;当前点击为特殊物品，序号\u0026#34; + objectIndex); ParticularJudgment(objectIndex); } else { Judgment(objectIndex); } Debug.Log($\u0026#34;当前点击次数为{currentClickedIndex}，当前正确次数为{currentExpectedIndex}，当前错误次数为{currentErrorIndex}\u0026#34;); } 点击判断的初步判断层，这里首先处理是否正确完成组合，因为是点击完成键才进行完成检测的，并且插入蛋糕组合，用简单的随机去控制\n// 记录玩家点击 playerInputSequence.Add(objectIndex); 本来是用来追踪正确与否的，后来改用了正确次数和错误次数两个变量来追踪，所以这个其实已经没用了，不过没删掉，万一有需要的地方呢。\n在此处通过判断序号实现特殊判断和普通判断的分割\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 //提示版的正负判断逻辑 void Judgment(int objectIndex) { // 更新动态提示 UpdateDynamicTips(); //传点击序号给最终确认脚本 Finalconfirmation.TriggerObjectClicked(objectIndex); // 检查是否正确 if (currentExpectedIndex \u0026lt; currentDigitArray.Length \u0026amp;\u0026amp; objectIndex == currentDigitArray[currentErrorIndex + currentExpectedIndex]) { // 正确提示显示 - 确保不越界 if (currentExpectedIndex \u0026lt; currentDigitArray.Length) { tipObject[currentErrorIndex + currentExpectedIndex].SetActive(true); } // 正确点击 currentExpectedIndex++; Debug.Log($\u0026#34;正确! 当前进度: {currentExpectedIndex}/{currentDigitArray.Length}\u0026#34;); } else { // 错误点击提示 - 确保不越界 if (currentErrorIndex + currentExpectedIndex \u0026lt; currentDigitArray.Length) { tipObject[5 + currentErrorIndex + currentExpectedIndex].SetActive(true); } // 错误点击 currentErrorIndex++; Debug.Log(\u0026#34;点击错误显示位置为 \u0026#34; + (4 + currentClickedIndex - 1)); } } //有加载动画的恢复次数逻辑 void ParticularJudgment(int objectIndex) { //此处判断全是硬编码，没有换循环---器械 if (objectIndex == 22 \u0026amp;\u0026amp; AnimateUICount[objectIndex - 12] == 3) { //clickCounts，loadObject，3*n StartSequence(10,10,4, true); Debug.Log($\u0026#34; 咖啡液 点击次数已恢复\u0026#34;); return; } if (objectIndex == 27 \u0026amp;\u0026amp; AnimateUICount[objectIndex - 12] == 3) { //clickCounts，loadObject，3*n StartSequence(15, 11, 5, true); Debug.Log($\u0026#34; 芝士 点击次数已恢复\u0026#34;); return; } if (objectIndex == 28 \u0026amp;\u0026amp; AnimateUICount[objectIndex - 12] == 3) { //clickCounts，loadObject，3*n StartSequence(16, 0, 6, true); Debug.Log($\u0026#34; 坚果 点击次数已恢复\u0026#34;); return; } //此处判断全是硬编码，没有换循环---水果 if (objectIndex == 23) { //clickCounts，loadObject，2 + 3*n StartSequence(9, 9, 0, false); Debug.Log($\u0026#34; 蓝莓 点击次数已恢复\u0026#34;); return; } if (objectIndex == 24) { //clickCounts，loadObject，2 + 3*n StartSequence(8, 8, 1, false); Debug.Log($\u0026#34; 橙子 点击次数已恢复\u0026#34;); return; } if (objectIndex == 25) { //clickCounts，loadObject，2 + 3*n StartSequence(7, 7, 2, false); Debug.Log($\u0026#34; 草莓 点击次数已恢复\u0026#34;); return; } if (objectIndex == 26) { //clickCounts，loadObject，2 + 3*n StartSequence(6, 6, 3, false); Debug.Log($\u0026#34; 薄荷 点击次数已恢复\u0026#34;); return; } // 处理其他特殊物品----点击自身恢复次数 if (SpecialexcludedObject.Contains(objectIndex)) { if (clickCounts[objectIndex] == 0) { //提拉美苏 樱花蛋卷 草莓蛋糕 17 18 19 //n用来追踪组 int n = 7; for (int i = 17;i\u0026lt;20;i++) { if (objectIndex == i \u0026amp;\u0026amp; AnimateUICount[objectIndex] == 3) { for (int ii = 0; ii \u0026lt; 3; ii++) { threeObject[ii + 3 * n].SetActive(true); } StartCoroutine(LittleWaitForAnimationFinish(threeObject[3 * n].GetComponent\u0026lt;Animator\u0026gt;(), objectIndex)); n = 7; } n++; } // 水 牛奶 茶 椰汁 巧克力 1 2 3 4 5 for (int i = 1; i \u0026lt; 6; i++) { if (objectIndex == i) { threeObject[53 - 4 * i].SetActive(true); // 激活threeloadObject并播放动画 11 4 5 6 7 threeloadObject[objectIndex].SetActive(true); // 启动特殊协程等待动画完成 StartCoroutine(LittleWaitForAnimationFinish(threeloadObject[objectIndex].GetComponent\u0026lt;Animator\u0026gt;(),objectIndex)); } } Debug.Log($\u0026#34;特殊物品 {objectIndex} 点击次数重置为 3\u0026#34;); } else { if (currentErrorIndex + currentExpectedIndex != currentDigitArray.Length) { clickCounts[objectIndex]--; threeJudgement(objectIndex); Judgment(objectIndex); Debug.Log($\u0026#34;特殊物品 {objectIndex} 点击次数减1，剩余: {clickCounts[objectIndex]}\u0026#34;); } } } else { // 如果不是SpecialexcludedObject或OtherexcludedObject中的特殊物品，属于普通的三次物品直接进行判定即可---那些水果 if (currentErrorIndex + currentExpectedIndex != currentDigitArray.Length \u0026amp;\u0026amp; !OtherexcludedObject.Contains(objectIndex)) { if (clickCounts[objectIndex] \u0026gt; 0) { clickCounts[objectIndex]--; threeJudgement(objectIndex); Judgment(objectIndex); Debug.Log($\u0026#34;其他特殊物品 {objectIndex} 点击次数减1，剩余: {clickCounts[objectIndex]}\u0026#34;); } else { Debug.Log($\u0026#34;其他特殊物品 {objectIndex} 点击次数已为0，不再减少\u0026#34;); } } } } 普通判断和特殊判断，这里的逻辑比较复杂，首先物体分为\n点击自己无限提供物体 冰 水 炼乳 焦糖 棉花糖 冰淇凌 点击自己提供三次物体 咖啡 芝士 坚果 蓝莓 橙子 草莓 薄荷 牛奶 茶 椰汁 巧克力 点击自己为他人恢复三次次数 咖啡 芝士 坚果 蓝莓 橙子 草莓 薄荷 对应的物体 点击自己为自己恢复三次次数 牛奶 茶 椰汁 巧克力 普通判断就是只判断是否点击有效，点击正确\n特殊判断则将他人恢复和自身恢复物体区分开并调整对应关系，然后判断是否点击有效，点击正确，点击次数减 1，点击次数为 0 则不再减少，以至于恢复。\n由于还要涉及动画的不同，动画分为\n有特定加载动画 牛奶 茶 椰汁 巧克力 水 无特定加载动画 咖啡 芝士 坚果 蓝莓 橙子 草莓 这里其实全部都用等待假进度条恢复次数就好，不过我属于那种实现一种方法又想实现另一种方法的人，所以分成了两种判断。\n第一种需要等待液体的加载动画完成才能恢复次数，恢复判定\n第二种通过假进度条恢复次数，恢复判定\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 /// \u0026lt;summary\u0026gt; /// 更新动态提示 /// \u0026lt;/summary\u0026gt; void UpdateDynamicTips() { // 显示当前步骤的动态提示 - 确保不越界 int tipIndex = Mathf.Min(currentErrorIndex + currentExpectedIndex + 1, DtipObject.Length - 1); // 隐藏所有动态提示 if (tipIndex != currentDigitArray.Length) { for (int i = 0; i \u0026lt; DtipObject.Length; i++) { if (i \u0026lt; DtipObject.Length) DtipObject[i].SetActive(false); } for (int i = 0; i \u0026lt; DDtipObject.Length; i++) { if (i \u0026lt; DDtipObject.Length) DDtipObject[i].SetActive(false); } } if (tipIndex \u0026gt;= 0 \u0026amp;\u0026amp; tipIndex \u0026lt; DtipObject.Length \u0026amp;\u0026amp; tipIndex \u0026lt; currentDigitArray.Length) { DtipObject[tipIndex].SetActive(true); } if (tipIndex \u0026gt;= 0 \u0026amp;\u0026amp; tipIndex \u0026lt; DDtipObject.Length \u0026amp;\u0026amp; tipIndex \u0026lt; currentDigitArray.Length) { DDtipObject[tipIndex].SetActive(true); } } /// \u0026lt;summary\u0026gt; /// 重置游戏状态 /// \u0026lt;/summary\u0026gt; private void ResetGameState() { // 玩家点击序号顺序其实没啥用（本来想用来校准用，不过直接用正确数确认也行） playerInputSequence.Clear(); // 重置掉三个追踪数 currentExpectedIndex = 0; currentErrorIndex = 0; currentClickedIndex = 0; // 重置正确与错误提示显示 for (int i = 0; i \u0026lt; tipObject.Length; i++) { tipObject[i].SetActive(false); } // 全部重置指针，防止提前重置 for (int i = 0; i \u0026lt; DtipObject.Length; i++) { if (i \u0026lt; DtipObject.Length) DtipObject[i].SetActive(false); } for (int i = 0; i \u0026lt; DDtipObject.Length; i++) { if (i \u0026lt; DDtipObject.Length) DDtipObject[i].SetActive(false); } // 初始指针需要被显示 if (DtipObject.Length \u0026gt; 0) DtipObject[0].SetActive(true); if (DDtipObject.Length \u0026gt; 0) DDtipObject[0].SetActive(true); } } 更新动态提示，重置游戏状态，重置三个追踪数，重置正确与错误提示显示，全部重置指针，防止提前重置，初始指针需要被显示。\n这里逻辑就很简单了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 //消逝动画赋予逻辑 void threeJudgement(int objectIndex) { //咖啡液 排序有问题只能单领出来了---上面注册消逝协程动画数也是单领的 if (objectIndex == 10) { //消逝协程动画数 if (AnimateUICount[objectIndex] != 3) { StartCoroutine(AnimateUI(threeObject[clickCounts[objectIndex] + 12], objectIndex)); } } //n用来追踪组 int n = 0; //三个蛋糕和芝士，坚果 for (int i = 15; i \u0026lt; 20; i++) { if (objectIndex == i) { //消逝协程动画数 if (AnimateUICount[objectIndex] != 3) { StartCoroutine(AnimateUI(threeObject[clickCounts[objectIndex] + 15 + 3 * n],objectIndex)); } } n++; } //蓝莓 if (objectIndex == 9) { if (clickCounts[objectIndex] != 0) { threeObject[clickCounts[objectIndex]].SetActive(false); threeObject[clickCounts[objectIndex] - 1].SetActive(true); } else { threeObject[clickCounts[objectIndex]].SetActive(false); } } //橙子 if (objectIndex == 8) { if (clickCounts[objectIndex] != 0) { threeObject[clickCounts[objectIndex] + 3].SetActive(false); threeObject[clickCounts[objectIndex] - 1 + 3].SetActive(true); } else { threeObject[clickCounts[objectIndex] + 3].SetActive(false); } } //草莓 if (objectIndex == 7) { if (clickCounts[objectIndex] != 0) { threeObject[clickCounts[objectIndex] + 6].SetActive(false); threeObject[clickCounts[objectIndex] - 1 + 6].SetActive(true); } else { threeObject[clickCounts[objectIndex] + 6].SetActive(false); } } //薄荷 if (objectIndex == 6) { if (clickCounts[objectIndex] != 0) { threeObject[clickCounts[objectIndex] + 9].SetActive(false); threeObject[clickCounts[objectIndex] - 1 + 9].SetActive(true); } else { threeObject[clickCounts[objectIndex] + 9].SetActive(false); } } //巧克力 if (objectIndex == 5) { threeObject[clickCounts[objectIndex] + 31].SetActive(false); threeObject[clickCounts[objectIndex] - 1 + 31].SetActive(true); } //椰汁 if (objectIndex == 4) { threeObject[clickCounts[objectIndex] + 35].SetActive(false); threeObject[clickCounts[objectIndex] - 1 + 35].SetActive(true); } //茶 if (objectIndex == 3) { threeObject[clickCounts[objectIndex] + 39].SetActive(false); threeObject[clickCounts[objectIndex] - 1 + 39].SetActive(true); } //牛奶 if (objectIndex == 2) { threeObject[clickCounts[objectIndex] + 43].SetActive(false); threeObject[clickCounts[objectIndex] - 1 + 43].SetActive(true); } //水 if (objectIndex == 1) { threeObject[clickCounts[objectIndex] + 47].SetActive(false); threeObject[clickCounts[objectIndex] - 1 + 47].SetActive(true); } } //协程：消逝特效动画 IEnumerator AnimateUI(GameObject targetUI,int objectIndex) { // 获取RectTransform和CanvasGroup组件 RectTransform rectTransform = targetUI.GetComponent\u0026lt;RectTransform\u0026gt;(); CanvasGroup canvasGroup = targetUI.GetComponent\u0026lt;CanvasGroup\u0026gt;(); //没有canvasgroup自动加 if (canvasGroup == null) { canvasGroup = targetUI.AddComponent\u0026lt;CanvasGroup\u0026gt;(); } // 记录初始值 Vector2 startPosition = rectTransform.anchoredPosition; float startAlpha = canvasGroup.alpha; // 目标值 Vector2 targetPosition = startPosition + new Vector2(0, 70f); float targetAlpha = 0f; // 动画持续时间（可根据需要调整） float duration = 0.35f; float elapsed = 0f; // 线性插值 while (elapsed \u0026lt; duration) { elapsed += Time.deltaTime; float t = elapsed / duration; rectTransform.anchoredPosition = Vector2.Lerp(startPosition, targetPosition, t); canvasGroup.alpha = Mathf.Lerp(startAlpha, targetAlpha, t); yield return null; } // 恢复初始值 rectTransform.anchoredPosition = startPosition; canvasGroup.alpha = startAlpha; targetUI.SetActive(false); //消逝协程动画数自增----最高到3 AnimateUICount[objectIndex]++; } 消逝动画的添加以及其协程的添加\n消逝动画并没有采用添加 animator 的方式实现，而是采用了直接通过脚本控制 canvasgroup 的 alpha 值来实现的，这样做的好处是可以更灵活地控制动画效果，比如可以设置不同的动画时间，不同的动画曲线等。\n小问题在于协程延后的问题，通过单一变量来追踪协程的话会出现，快速点击时，第一次的协程被追踪，其他的协程也已经开始，最终协程追踪第三次点击的协程，当点击到恢复次数时，会出现第二次协程未完毕的情况，，应该是 yield return null;延迟一帧的锅吧，并没有排查到具体原因，当时采用这种变量自增来跟踪 AnimateUICount[objectIndex]++;避免了\n小小缺点就是还得想法实现中间点击也能恢复次数，因为加了这个消逝动画三次恢复次数的判断用的这个变量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 // 加载动画---点击他人恢复次数 public void StartSequence(int clickCountsobject,int loadobject,int n,bool YNthree) { // 激活threeloadObject并播放动画 threeloadObject[loadobject].SetActive(true); // 获取动画组件并播放 Animator animator = threeloadObject[loadobject].GetComponent\u0026lt;Animator\u0026gt;(); if (animator != null) { animator.SetTrigger(\u0026#34;Load Animation\u0026#34;); // 启动协程等待动画完成 StartCoroutine(WaitForAnimationFinish(animator,clickCountsobject,loadobject, n, YNthree)); } else { Debug.LogError( threeloadObject[loadobject].name + \u0026#34;上没有Animator组件！\u0026#34;); } } // 协程：等待动画播放完成----点击他人供应的 IEnumerator WaitForAnimationFinish(Animator animator, int clickCountsobject, int loadobject, int n, bool YNthree) { // 等待动画开始播放 yield return new WaitForEndOfFrame(); // 获取当前播放的动画状态信息（层索引默认为0） AnimatorStateInfo stateInfo = animator.GetCurrentAnimatorStateInfo(0); // 等待动画播放完成（normalizedTime \u0026gt;= 1表示播放完毕） yield return new WaitWhile(() =\u0026gt; animator.GetCurrentAnimatorStateInfo(0).normalizedTime \u0026lt; 1); // 动画播放完成后执行的操作 ExecuteAfterAnimation(clickCountsobject,loadobject, n, YNthree); } // 动画完成后执行：激活目标对象并禁用源对象 void ExecuteAfterAnimation(int clickCountsobject, int loadobject, int n,bool YNthree) { //重置次数 clickCounts[clickCountsobject] = 3; if (YNthree) { // 激活threeObject for (int i = 0; i \u0026lt; 3; i++) { int index = i + 3 * n; if (threeObject[index] != null) { threeObject[index].SetActive(true); } else { Debug.LogWarning($\u0026#34;threeObject[{index}] 未赋值！\u0026#34;); } } } else { threeObject[2 + 3 * n].SetActive(true); } //靠他人恢复的重置 if (clickCountsobject == 10 || clickCountsobject == 15 || clickCountsobject == 16) { //重置消逝协程动画数 AnimateUICount[clickCountsobject] = 0; } // 禁用threeloadObject threeloadObject[loadobject].SetActive(false); } // 协程：等待动画播放完成----为有特殊的加载动画的物体服务（点击自身供应的） IEnumerator LittleWaitForAnimationFinish(Animator animator, int objectIndex) { // 等待动画开始播放 yield return new WaitForEndOfFrame(); // 获取当前播放的动画状态信息（层索引默认为0） AnimatorStateInfo stateInfo = animator.GetCurrentAnimatorStateInfo(0); // 等待动画播放完成（normalizedTime \u0026gt;= 1表示播放完毕） yield return new WaitWhile(() =\u0026gt; animator.GetCurrentAnimatorStateInfo(0).normalizedTime \u0026lt; 1); // 动画播放完成后执行的操作 clickCounts[objectIndex] = 3; if (objectIndex \u0026lt; 6) { // 取消激活threeloadObject threeloadObject[objectIndex].SetActive(false); } else { //重置消逝协程动画数 AnimateUICount[objectIndex] = 0; } } 这里的加载动画的实现，主要是通过激活 threeloadObject 并播放动画，然后等待动画播放完成，再执行动画完成后的操作，这里的动画播放完成的判断是通过 normalizedTime 来实现的，当 normalizedTime 等于 1 时，表示动画播放完毕。\n动画播放完成后执行的操作主要是激活目标对象并禁用源对象，这里的目标对象是 threeObject，根据点击的序号来确定三个物体的位置，并激活。\n比较简单不做追叙。\n追加动画逻辑 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 using System; using System.Collections; using System.Collections.Generic; using UnityEngine; public class Finalconfirmation : MonoBehaviour { [Header(\u0026#34;成品一层\u0026#34;)] [Tooltip(\u0026#34;按顺序排列序号\u0026#34;)] public GameObject[] targetObjectOne; // UI 图像 [Header(\u0026#34;成品二层\u0026#34;)] [Tooltip(\u0026#34;按顺序排列序号\u0026#34;)] public GameObject[] targetObjectTwo; // UI 图像 [Header(\u0026#34;成品三层\u0026#34;)] [Tooltip(\u0026#34;按顺序排列序号\u0026#34;)] public GameObject[] targetObjectThree; // UI 图像 [Header(\u0026#34;成品特殊材料\u0026#34;)] [Tooltip(\u0026#34;按顺序排列序号\u0026#34;)] public GameObject[] particularObject; // UI 图像 [Header(\u0026#34;成品\u0026#34;)] [Tooltip(\u0026#34;按顺序排列序号\u0026#34;)] public GameObject[] finallyObject; // UI 图像 //委托事件 public static event Action\u0026lt;int\u0026gt; OnObjectClicked; // 存储已激活的对象用的列表，以便后续禁用 private List\u0026lt;GameObject\u0026gt; activatedObjects = new List\u0026lt;GameObject\u0026gt;(); int currentLayer = 1; bool firstice = false; // 启用时订阅事件------使用 OnEnable 和 OnDisable 来订阅和取消订阅事件 void OnEnable() { OnObjectClicked += HandleObjectClicked; } // 禁用时取消订阅事件 void OnDisable() { OnObjectClicked -= HandleObjectClicked; } //静态方法只负责触发事件，不包含业务逻辑 public static void TriggerObjectClicked(int objectIndex) { OnObjectClicked?.Invoke(objectIndex); } IEnumerator fadeIce(GameObject iceobjecet) { CanvasGroup canvasGroup = iceobjecet.GetComponent\u0026lt;CanvasGroup\u0026gt;(); float startAlpha = canvasGroup.alpha; float targetAlpha = 0f; // 动画持续时间（可根据需要调整） float duration = 0.35f; float elapsed = 0f; // 线性插值 while (elapsed \u0026lt; duration) { elapsed += Time.deltaTime; float t = elapsed / duration; canvasGroup.alpha = Mathf.Lerp(startAlpha, targetAlpha, t); yield return null; } canvasGroup.alpha = startAlpha; Debug.Log(\u0026#34;动画完成\u0026#34;); iceobjecet.SetActive(false); } IEnumerator fadeAll(GameObject allobjecet,int objectIndex) { if (objectIndex == 20 \u0026amp;\u0026amp; currentLayer == 4) { finallyObject[1].SetActive(true); finallyObject[2].SetActive(true); yield return new WaitForSeconds(finallyObject[2].GetComponent\u0026lt;Animator\u0026gt;().GetCurrentAnimatorStateInfo(0).length); } RectTransform rectTransform = allobjecet.GetComponent\u0026lt;RectTransform\u0026gt;(); CanvasGroup canvasGroup = allobjecet.GetComponent\u0026lt;CanvasGroup\u0026gt;(); Vector2 startPosition = rectTransform.anchoredPosition; float startAlpha = canvasGroup.alpha; Vector2 targetPosition = startPosition + new Vector2(0, 70f); float targetAlpha = 0f; // 动画持续时间（可根据需要调整） float duration = 0.35f; float elapsed = 0f; // 线性插值 while (elapsed \u0026lt; duration) { elapsed += Time.deltaTime; float t = elapsed / duration; rectTransform.anchoredPosition = Vector2.Lerp(startPosition, targetPosition, t); canvasGroup.alpha = Mathf.Lerp(startAlpha, targetAlpha, t); yield return null; } rectTransform.anchoredPosition = startPosition; canvasGroup.alpha = startAlpha; allobjecet.SetActive(false); //杯套杯盖 finallyObject[1].SetActive(false); finallyObject[2].SetActive(false); // 禁用所有之前激活的对象 foreach (GameObject obj in activatedObjects) { if (obj != null) { obj.SetActive(false); } } //重置值 firstice = false; // 清空列表 activatedObjects.Clear(); currentLayer = 1; allobjecet.SetActive(true); Debug.Log(\u0026#34;最终动画完成\u0026#34;); } public void HandleObjectClicked(int objectIndex) { //冰初次特殊处理 if(objectIndex == 0 \u0026amp;\u0026amp; !firstice) { particularObject[10].SetActive(true); activatedObjects.Add(particularObject[10]); firstice = true; return; } if (objectIndex \u0026lt; 17 \u0026amp;\u0026amp; objectIndex != 0) { //独立的错误提示 particularObject[11].SetActive(false); GameObject[] currentArray = null; // 根据当前层数选择对应的数组 switch (currentLayer) { case 1: currentArray = targetObjectOne; break; case 2: currentArray = targetObjectTwo; break; case 3: currentArray = targetObjectThree; break; } if (objectIndex \u0026gt; 10 \u0026amp;\u0026amp; objectIndex \u0026lt; 17) { if (currentLayer == 4) { particularObject[objectIndex - 7].SetActive(true); activatedObjects.Add(particularObject[objectIndex - 7]); return; } else { //独立的错误提示 particularObject[11].SetActive(true); return; } } if (currentArray != null) { //冰特殊处理 if(firstice) { Debug.Log(\u0026#34;有首次冰存在\u0026#34;); StartCoroutine(fadeIce(particularObject[10])); //手动关一下前面的冰免得重影 if(currentLayer == 2) { StartCoroutine(fadeIce(targetObjectOne[0])); } else if(currentLayer == 3) { StartCoroutine(fadeIce(targetObjectTwo[0])); } currentArray[0].SetActive(true); activatedObjects.Add(currentArray[0]); } //固定层的物体额外启用 if (objectIndex \u0026gt; 5 \u0026amp;\u0026amp; objectIndex \u0026lt; 10) { particularObject[objectIndex - 6].SetActive(true); activatedObjects.Add(particularObject[objectIndex - 6]); } currentArray[objectIndex].SetActive(true); activatedObjects.Add(currentArray[objectIndex]); // 执行点击成功后的操作 Debug.Log($\u0026#34;层 {currentLayer} 中的对象 {objectIndex} 被点击\u0026#34;); // 增加层数，但不超过3层----超过三层就空了----空了就不执行 if (currentLayer \u0026lt; 4) { currentLayer++; } } else { // 执行点击失败后的操作 Debug.Log($\u0026#34;层 {currentLayer} 中的对象 {objectIndex} 没有被设置最终图\u0026#34;); } } if(objectIndex == 20 || objectIndex == 21) { StartCoroutine(fadeAll(finallyObject[0], objectIndex)); } } } 直接通过委托事件获取点击的物体的序号来触发点击事件，并在点击事件中执行具体的业务逻辑。\n冰比较特殊，首次点击和后面的点击动画不一样，所以要拆分出来\n薄荷等水果也比较特殊，是固定位置的特效，所以同样单独处理\n由于杯子最多填充三次液体，所以液体类只能追加三层\n这里忘了咖啡也比较特殊，当咖啡在二三层时，需要额外激活一段小动画，所以也要单独处理下，不过由于忘了，所以没加\n总结 大部分动画都是用的启用即播放这一特点，一个物体承载动画，当该物体被启用时播放。\n通过复制同一物体或脚本复制 animator 值来实现动画的复用。\n协程的使用可以实现多次点击动画，以及延迟的功能\n由于开始不希望涉及脚本间通信，所以游戏核心脚本有点臃肿了，个人回头看都感觉有点难受\nBGM 和音效的添加就很简单了，由于只是练练手防止手生，就不加这些功能了。\n耗时一周左右，中间有搁置，因为打上游戏了，闲的没事干抽空写写，加起来大概一千多行的小游戏，不过还是很有意思的。\n","date":"2025-08-20T20:58:22+08:00","image":"https://axppk.github.io/p/%E5%B0%91%E5%89%8D2%E6%96%B9%E7%B3%96%E5%96%B5%E5%92%96%E9%A6%86%E5%A4%8D%E5%88%BB/img/3_hu_eb4874759ea739fd.png","permalink":"https://axppk.github.io/p/%E5%B0%91%E5%89%8D2%E6%96%B9%E7%B3%96%E5%96%B5%E5%92%96%E9%A6%86%E5%A4%8D%E5%88%BB/","title":"少前2方糖喵咖馆复刻"},{"content":"前言 第三个无三视图人体模型，这次做三个，先做一个裸模做基础，然后三套衣服，甚至三个头发。\n头发还是挺有挑战的，我的是面片法，不一定全适合。\n裸模没有三视图更是折磨。。用其他人的当作参考自己调整（不能直接用其他人的，毕竟都已经应用了修改器，而且大部分和这体型不一样）。\n感觉都不错啊，不过估计时长会长不少，毕竟单靠一张透视图去做还是有点难度的。\n过程 脸模制作 先以第一个图为基础，做一个脸模出来，毕竟这张图的脸还算正。这张图嘴是张开的，而且幅度很大，那后面的形态键应该怎么做呢（问题暂留） 捏好脸 简单上色 捏刘海 捏头发 身体制作 基础的胸部 整个身体 脚部，这些指甲布线真麻烦，还有人体的结构 完成身体 后发的补充，这里的分层不会做，只能是在一个整体上切割了，效果一般，卡了我不少时间 衣服制作 简单的衣服，头发也上了下纹理，感觉头发好像分层有点严重。（要不加个帽子掩盖一下哈哈） 有点诡异，这西装没有参考还真不好做。 暂时完成，有需要再改吧 细节制作 搁置一段时间，又回来补充了一下 加上了描边 效果依旧一般，很奇怪 最终成果，仍然是没有权重。权重真的好麻烦。 ","date":"2025-08-04T14:10:45+08:00","image":"https://axppk.github.io/p/%E6%B5%85%E9%BB%84%E7%9D%A6%E6%9C%88%E4%B8%89%E6%A8%A1%E5%9E%8B%E5%88%B6%E4%BD%9C/back_hu_87067108ac8f978d.png","permalink":"https://axppk.github.io/p/%E6%B5%85%E9%BB%84%E7%9D%A6%E6%9C%88%E4%B8%89%E6%A8%A1%E5%9E%8B%E5%88%B6%E4%BD%9C/","title":"浅黄睦月三模型制作"},{"content":"前言 心血来潮，3d 化一下可爱的长风。\n第二个无三视图人体建模，由于是玩偶，所以没有建的那么圆，反而有点扁平。\n只靠一张图去建模还是有点难度的，总共耗时五天。\n原参考图是 AI 图，其实建模的时候就感觉有点奇怪，为什么有些地方模糊混乱。。。画纹理的时候直接就是看不清细节，只能凭感觉，加上褶皱和阴影画的少，直接给自己画崩溃了，所以直接就这样吧。\n过程记录 首先是头部，由于没有三视图，只能先用正视图打底，而且这个姿势歪的也不是很厉害，所以直接照着建好了。 超快速调整出整个身体大小和部分头发。主要还是刘海，其他的其实不重要。 简单画上眼睛，方便定型和调整。 同样的，方便纠正感觉，把刘海也做出来。 进一步制作，帽子和后发。 双马尾，其实这里我偷懒了，本来想用线条去堆，但是刚开始用面片做的发丝太好看了，不忍心，就直接弄了个空心的柱子，贴上发丝即可。 偷懒先做鞋子，因为简单。 上衣部分开始 由于不会雕刻，所以褶皱就只能古法折叠，效果一般。 基本模型建好了，简单的分分材质。 画点简单的纹理（这时候还没意识到，原图是 AI 图，所以仍然在凭感觉画） 崩溃了，暂时纹理就这样吧，原图太糊了，看不清具体图案和细节。（而且褶皱的阴影好难画） 结束 单个图建模很容易出现身体走型问题，只靠正试图建模容易出现纸片人的情况，所以一定要及时调整形体。\n不要依赖 AI 图建模！！！！而且为什么每次图都这么模糊，很难看清细节，感觉做几个模型，视力下降好多。\n手指有点疼，给自己点休息时间吧。\n","date":"2025-08-01T20:56:27+08:00","image":"https://axppk.github.io/p/%E9%95%BF%E9%A3%8E%E7%8E%A9%E5%81%B6%E5%BB%BA%E6%A8%A1/back_hu_e69bdb1c85a99db6.png","permalink":"https://axppk.github.io/p/%E9%95%BF%E9%A3%8E%E7%8E%A9%E5%81%B6%E5%BB%BA%E6%A8%A1/","title":"长风玩偶建模"},{"content":"前言 开始的动力来源于一篇白丝的 sharder 制作教程（我认为这个应该属于程序化纹理？），真的熟练，真的强。\n为了学会 PBR 和 NPR，需要先了解其原理，所以先入门一下 3D 数学，了解一些基本的概念和公式。可能还需要学习下 OpenGL 框架。\n之后系统学习自定义 Sharder，之后才能自己去选择方向实现 PBR 和 NPR。\n可怜的老师傅，为众人拾薪者，冻毙于荒野，这个 up 讲的很基础很明白，结果被干破防了，真的很惋惜。要是能回归看到它的更多教程就好了，也不至于学的这么混乱。\n生啃 games101 简直就是噩梦！！！\n这些应该都属于是 TA 岗需要的吧，想要成为一个合格的建模师，需要考虑这个吗，我不是很清楚，但是我的模型现在只有 basecolor，表现很差。\n感觉会有用的:\n知乎讨论\nblender 的程序化纹理\nb 站视频\nb 站视频 2\nb 站视频 3\n星穹铁道 unity 纯享版 卡通渲染 shader URPsharder 入门 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 Ctrl Shift 左键点击 预览当前节点 F 连接节点 Shift D 复制节点 H 隐藏节点 Ctrl H 隐藏不用的接口 M 禁用/启用节点 Ctrl X 消除 Alt D 分离节点，但会把原来的连线也弄没了 L 选择左边面相连的节点 Shift L 选择右边面相连的节点 Ctrl J 加框 Ctrl G 打组 合成器 背景图像预览控制 V 缩小背景图像 Alt V 放大背景图像 Alt Home 背景图像适配窗口 Alt 中键 移动背景图像 Node Wrangler 专属 Ctrl T 图像纹理三件套 Ctrl Shift T PBR 纹理 Alt R 重载图像 Shift S 修改当前节点类型 Ctrl 右键拖动 切断 Alt 右键拖动 连接 Alt Shift 右键拖动 连接 可以选源点和目标点 选中两个或多个 按 K 键也可以连接 Alt S 切换连接目标点，也可交换两个输入点 Ctrl + - _ / 对两个同类节点进行各种混合 Alt + - _ / 把当前节点混合模式改为 + - \\* / Alt ← → 调整节点里的系数 上下键切换节点的模式 Ctrl Shift 右键拖动 建立两个节点的混合模式 Shift 右键拖动 切出转接点 Alt X 清除没用的节点 Alt 拖动 拆离节点 Shift P 加框 Shift = 强迫症患者专用 学习记录 这些手搓 sharder 的真是怪物，这是熟能生巧吗。\nsharder 是实现渲染效果的一种编程语言，可以实现各种各样的效果，比如 PBR，NPR，卡通渲染，甚至还可以实现一些游戏特效。\n原理貌似是通过灰度图和颜色图来控制显示。\n","date":"2025-07-24T22:54:54+08:00","permalink":"https://axppk.github.io/p/3d%E6%95%B0%E5%AD%A6%E4%B8%8Esharder%E5%AD%A6%E4%B9%A0/","title":"3D数学与Sharder学习"},{"content":"前言 纯瘾大，最近碧蓝档案国际服周年庆，fes200 抽全出了，非常高兴，仿制一下莉音藏身处的场景，场景模型由 blender 制作搭建，UV 贴图由 SP 和 PS 制作，耗时一周，其实不到一周，每天做俩小时，五天做完，一共 10+ 小时，不过质量其实堪忧，细节处理不是很到位，毕竟，是根据截图来做的，所以很多只能是主观臆想。\n其实后面还做了个圣娅纸箱，不过工程量很小，不值得写个博客了。\n流程记录 第一天，搭建初步模型，大多数白膜，摆个占位就可以了，这次的占位其实摆的不是很好，后面快做完了，感觉长度给小了，导致右边显得很挤，参考截图上给人一种 2.5d 的感觉（可能），总之就是我摆出来的效果不是很好。 进一步摆出更多物品，这一块很简单。 第二天，犯了懒病，不是很想直接扣细节，所以开始绘制简单的 UV 贴图，在有材质的情况下去再次调整占位布局。 最后的调整效果，并且把墙连了起来，挺好玩，这个模型的墙是曲线链接的，是个曲面。 第三天，绘制细节，补充场景物品，画更多的 UV，主要耗时点在于绘制 UV 和调整 UV，这块没截 SP 的图，反复找各种笔刷。 第四天，制作前衡君模型，这个摩西模型在参考图里很模糊，而且 ba 的建模也偷懒了，原画里这东西还挺复杂，不过这里仿制的游戏场景的截图，所以我也偷懒。 这东西确实复杂，不过上色很简单。 第五天，基本完成，调整一些纸团的细节，杂物等 最终完成，收容场景物品，分类，最后收工并记录。 结束 同样的，没有什么难度，毕竟是个人练习，没有什么精度要求，也没有面数显示，硬要说经验的话，可能是对于这种圆滑的模型，模型中那些接缝感，是通过倒角修改器（倒角）实现的，单纯的去挤出，做出来那种感觉，很差，并且倒角修改器，当面有点混乱时，会失去作用，比如有断面，断线，可能原因是这些面，线，点导致倒角修改器认为这些线离得很近，不用或者没法去倒角吧，maybe，理解不是很到位。\n总之机箱就是一个很大的败笔，因为是刚开始做的，导致它很硬，很直，也懒得改了。而后面做的那个地上的小柜子就会好很多，所以尽量还是避免挤出和内插，多用拆分会更好，在展 UV 的时候也会更舒服。\n倒角修改器在导出时被应用，UV 会被分开，在 SP 中绘制的时候可能会出现 UV 块丢失的问题，很雷人，感觉是模型的问题。\nSP 不能够乱加模型，所以最好还是一批一批的绘制模型的贴图。\n","date":"2025-07-22T16:48:42+08:00","image":"https://axppk.github.io/p/%E7%A2%A7%E8%93%9D%E6%A1%A3%E6%A1%88%E5%9C%BA%E6%99%AF%E4%BB%BF%E5%88%B6/back_hu_183de95f66406050.png","permalink":"https://axppk.github.io/p/%E7%A2%A7%E8%93%9D%E6%A1%A3%E6%A1%88%E5%9C%BA%E6%99%AF%E4%BB%BF%E5%88%B6/","title":"碧蓝档案场景仿制"},{"content":"前言 第一次尝试改模，挺冷门的角色，由于没有三视图，只能找个别人做好的模型改了（默认裸模的眼睛材质有问题，需要替换其他版本模型的 eye3 材质，它自带的 eye 好像和发影一样调整了透明度），主要添加便装\n内衣和百褶裙挺好做的，直接正方体细分就可以了，百褶裙网上有教程，40 顶点的圆环可以调整出来，鞋子模型有点讲究，因为刚开始跟的二比豆包的图，导致建错了模型，后期又费力改了回来\n参考链接：【Blender】JK 百褶裙怎么建模？一个视频弄明白！\n飞鸟马时 模型下载（不知道可不可以二次修改）\n【动漫人物鞋子参考】一网打尽超多种类的鞋~（文末附素材下载）\nBlender+SP | 制服鞋制作全过程\n这两个很简单，一小会就做完了 鞋子对比，以及由于没有细分导致的破面，调整布线，或者松弛周围顶点，或者加线，或者其他布线方法就可以解决。 材质用 PT 做，先烘焙 2k 贴图，然后基本色，补充其他细节，最后导出，目前只用到了粗糙度和基本色，法向有点问题（目前没调整出来原图的颜色，质感差好多）。 最后完成，修复了下裙子阴影和领口蝴蝶结位置 结束 个人感觉比较简单，并且耗时不是很长，上衣其实不太满意。 由于比较懒，所以没有做衣服的骨骼绑定，后期有空再来补充吧，并且摆出想要的 pose，她真的好好看。 ","date":"2025-07-14T23:35:22+08:00","image":"https://axppk.github.io/p/%E9%A3%9E%E9%B8%9F%E9%A9%AC%E6%97%B6%E4%BE%BF%E8%A3%85%E6%94%B9%E6%A8%A1/back_hu_12fd57b1565ef9e7.png","permalink":"https://axppk.github.io/p/%E9%A3%9E%E9%B8%9F%E9%A9%AC%E6%97%B6%E4%BE%BF%E8%A3%85%E6%94%B9%E6%A8%A1/","title":"飞鸟马时（便装）改模"},{"content":"前言 根据查询资料，直接调用各大搜索引擎的 API 接口，引入下展示的形式就可以了？大部分需要收费，不太具有研究意义。\n参考链接：\n五分钟为你的项目添加 ai 小助手\nDeepSeek 接入 Unity 制作一个二次元 AI 老婆\n前端如何接入 ai\n如何在 GitHub 上安装和配置 GPT\nGithub 的 AI 部署：如何在 GitHub 上管理和部署人工智能项目————疑似胡扯\nFree-GPT4-WEB-API：自托管的免费 GPT-4 Web API 解决方案\n免费 GPT4-WEB-API\nfastai\nfastgpt\nchatbase\n实现 此处以 chatbase 为例，需要注册账号，创建项目，私人改公共，获取 API Key。\n图示介绍：\n流程： ","date":"2025-07-12T18:29:42+08:00","permalink":"https://axppk.github.io/p/%E7%BD%91%E7%AB%99%E6%8E%A5%E5%85%A5ai%E5%8A%A9%E6%89%8B%E7%9A%84%E5%B0%9D%E8%AF%95/","title":"网站接入AI助手的尝试"},{"content":"参考链接 FernNPR：开源 NPR 项目\n对应的仓库 【深入浅出】PBR 与 BRDF 的原理以及在 Unity 中的实现\n[Unity URP Shader]NPR 融入一点 PBR 的角色渲染以及 RenderFeature 拓展管线应用\n对应的仓库 前言 个人认知下，这些渲染，特效，应该都是 TA 岗需要的技能，但感觉这些都比较难，详细的教程要么浅显，要么付费，目前大二即将大三甚至都还没接触，渲染和打光真的让我很头疼。 感觉应该不会做不出来，毕竟看评论，同年龄的人花了 10 天就做出来了。 已搁置\u0026mdash;不想了解图形学 ","date":"2025-07-08T19:40:43+08:00","permalink":"https://axppk.github.io/p/npr%E6%B8%B2%E6%9F%93%E5%B0%9D%E8%AF%95/","title":"NPR渲染尝试"},{"content":"前言 模型使用 blender 制作，贴图使用 PT 制作。\n由于模型制作周期过长，前期已经没法追溯了，后期做类似模型再记录吧。\n骨骼绑定 参考视频blender 教程丨【绑定篇】第 ② 集-卡通角色建模教程（头发衣服权重-上） 创建 blender 自带骨架，删除多余骨骼，通过自动权重先默认绑定。\nblender 中好像后选的是父级，所以先选骨架后选角色模型，ctr+P 绑定骨骼附带自动权重。\n自带权重一般效果不佳，通过模型的点层级调整对应的顶点权重。 衣服权重不用传统的绑定方式，直接用数据传递，通过数据传递修改器获取角色身体顶点组，传递给衣服。\n复制一个身体用作数据传递的身体，此方法可以避免数据传递的一些可能的小 bug（部分网格无法传递），添加上骨架，并且隐藏显示修改器结果（避免影响模型）。\n衣服添加数据传递修改器（须在骨架修改器上方），他的父级身体，勾选顶点数据，顶点组，映射选择 最近的面插值，然后点击生成数据层，调整原身体骨架，观察效果。\n太痛苦了，人体权重有问题的话将导致衣服各种抽搐！！！\n数据传递的绑定方法，用于数据传递的物体位置和形状越接近，效果越好。\n合并了身体，重新调整权重，修复后基本是这样，不仔细看其实不太能看出来权重的问题，效果还行 饰品绑定：除固定式的，蝴蝶结发饰直接添加骨架，通过 head 头部顶点组控制，其他的都可以用数据传递，直接绑定到对应的父级衣服上（因为他们会根据衣服拉伸）。 小翅膀绑定：新建骨骼，添加简单的面片，用来数据传递调整位置，然后通过数据传递修改器绑定到翅膀的顶点组上。\n好处：调整面片的顶点位置就可以快速出效果。 头发绑定：同小翅膀绑定，都是数据传递的方式添加骨骼，面片。 头发后发绑定：这个比较复杂，需要通过低边圆柱体调整至头发大小（头发当时也是用低边圆柱体做的），建好对应骨骼，通过自动权重用后发骨骼控制低边圆柱体，然后用数据传递给后发，同样的，顶部顶点调整为 head 控制。\n最后挤出低边圆柱体面更大范围控制头发，避免穿模。 补充：通过添加蒙版顶点组让一些不该动的头发不受骨骼控制 裙摆部分绑定：同样的有点小复杂，复制外套面片调整至合适位置和大小，添加骨骼，自动权重绑定，然后数据传递到裙摆上。\n（此处由于该数据传递修改器之前还有一层数据传递，所以第二个数据传递也需要有第一层的顶点组，否则会导致不规则变形，所以需要多加一部，选择物体，选择骨架，添加空顶点组，保证第二层不影响第一层）\n通过裙摆的顶点组控制裙摆的摆动（如果不添加裙摆的蒙版顶点组会导致上方衣服也跟着动\u0026mdash;原因是有两层数据传递）。 基本绑定结束，摆出个造型不至于衣服乱飞，~~~ 目前袖子，挎包，鞋的数据传递有问题，需要调整，后期应用修改器再补充 ~~。 补充绑定：鞋子上的绒球，比较简单，应用修改器后，找到对应的控制骨骼，添加上再光滑就行了，个别点可以直接修改顶点权重。\n小技巧：骨架修改器前面有覆盖层，可以显示着姿势调整顶点。\n如过对已经应用镜像修改器后的不满意，调整一边的顶点权重，另一边不会自动同步，此时可以用 Automirror 插件重新镜像顶点权重。 摆袖！！脖子颈部！！！（此处裙摆因为乱用细分，导致数据传递有问题，花边乱飞，最后只能平滑权重勉强慢慢调整的能看了——————使用光滑姿态骨，不要全部光滑，默认是全部光滑，很痛苦，此处选择第二个） 形态键创建 其实如果不用于制作姿势海报的话不需要做这个，毕竟模型也不用于 VRCHATE，不过多会一点是一点。\n新建基类，创建形态键的前提是这个模型不再进行大范围顶点变化，拓扑之类的，此外细分等修改器也需要提前应用，否则形态键重做，需要小范围顶点调整就在基类调整，形态键的原理是通过顶点的位置变化来控制模型的形状。这个是由编辑器自己计算的。\n补充：由于修改器问题，我甚至还重新去 PT 修改了材质，学会了怎么用 PT 二次修改,在放了一堆材质球画笔那点加号导入图片，直接拖到对应的模型上，右键贴出来的图，设置实际大小，填充，之后就可以在这上面修改了，只测试了 BaseColor，可能其他的需要重新烘焙。\nSubstance Painter 怎么导入贴图？Substance Painter 导入贴图方法\n通过调整值，控制变化，还挺好玩的，不过有命名规范，眉毛变化 BRW，嘴巴变化 MTH，眼睛变化 EYE，头发变化 HFR，衣服变化 CLO，裙摆变化 SKT，等等。 将单个表情互相混合，制作出最终的喜怒哀乐表情，用到的重要功能是创建混合后的新功能。\n还有个用于快速调整大面积顶点的功能，从形状混合（从形态键中混合） 喜怒哀乐惊表情展示 星星眼，爱心眼等眼部变化表情的形态键\n需要调整 UV，加上贴图，可以在 PS 里做，新建面片放在合适的位置，记得打开矫正面属性，否则 UV 会随着面拉伸变形。 补充：这里其实省略了 wink 这种形态键，因为非对称形态键需要应用掉镜像修改器，而前面的对称形态键又需要镜像修改器，所以这里需要用到插件 shapekeyutil，懒得加了，以后用到再来加。\n还省略了铁青脸形态的制作，和星星眼等制作方法一样，不过这种局部透明（渐变）的就需要放在高光贴图里，星星眼的制作放在任意贴图都可以（这里放在脸部贴图中），PS 里画出来，复制脸部前面然后分离，赋予高光贴图，调整 UV 然后，调整下透明方式（blender 中需要调整，否则可能渐变效果不是那么好）\n阴影补充 说白了其实是发影，和铁青脸制作方法一致，需要用到渐变，所以仍然放在高光贴图中，至于为什么要做发影，因为这种动画风格的，大部分阴影都是画上的，就像制作 UV 中，物体上的阴影都是画上去的。 导出模型 最终还是需要插件 shapekeyutil 应用掉有形态键的脸部等修改器，全部修改器应用，最后调整人物尽可能标准的靠近地面（包括骨头），更改各个部分名字（中文不标准，但能看懂） 没有做材质分割，整体仍使用一个材质中，没有调整法线，没有做骨骼适配。 现阶段最终版 材质分割，眉毛，前面部，高光，需要单独分出材质，方便后期调整材质渲染，如果是一般渲染的就不需要分割出来了 骨骼细分，添加总的控制骨，这里细分方便后期布料结算可以更好的摆动，在模型中因为是后分的，所以没有权重（他不能控制任何面） unity 中效果，因为刚开始在 blender 中用的巧法实现的描边，所以单独分出来一个去掉描边的版本，实体化实现的描边会导致部分模型细节被遮挡\n（如果添加修改器之前这个模型面有问题，就会导致白膜挡住原本材质，可以在 unity 中更换材质顺序解决，但仍有丢失细节问题，这个是导致问题的重要原因）\n（用的-0.001 参数向内缩小，避免在 blender 中遮挡细节，但在 unity 中由于没有对应材质，会导致白模，总之是个可选项） 形态键测试，效果还好，基本符合 blender 制作中的效果。 unity 中模型材质调整，眉毛通过 renderQueue 可以控制，但是 VRM1.0 中的 renderQueue 不太会用，调了没效果，眉毛在最上层，其次前发，其次发影，最后脸部 补充：VRM 官方文档-汉化版 -【UniVRM】 ","date":"2025-07-06T19:38:14+08:00","image":"https://axppk.github.io/p/%E8%B5%9B%E7%92%90%E7%92%90%E9%A3%8E%E4%BA%BA%E7%89%A9%E6%A8%A1%E5%9E%8B%E5%88%B6%E4%BD%9C/back_hu_cb2b4b01b64ab37b.png","permalink":"https://axppk.github.io/p/%E8%B5%9B%E7%92%90%E7%92%90%E9%A3%8E%E4%BA%BA%E7%89%A9%E6%A8%A1%E5%9E%8B%E5%88%B6%E4%BD%9C/","title":"赛璐璐风人物模型制作"},{"content":"前言 NIKKI 联动尼尔的启动动画看着好棒，想搬来当自己的启动动画，但是很明显没有现成的，只能自己做（耗时 4 小时）。\n没有合适的字体，所以采用的是网站字体。\n动画效果采用的是 CSS 动画和 js 动画混合，效果还行，暂时还没做转场（10 个特定线生长，菱形变化）。\n更多动画，没有动手能力的可以去UIverse找。\n参考链接：【NIKKE 胜利女神】OuteR:Automata 尼尔联动 剧情纯享 完结 横屏 2K60 帧\n补充 莫名其妙手机访问的话会很慢加载资源，甚至无法加载 效果预览 效果预览\n代码 基本实现： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;style\u0026gt; @font-face { font-family: \u0026#39;MyCustomFont\u0026#39;; src: url(\u0026#39;/font/MarukoGothicCJKjp-Regular.ttf\u0026#39;) format(\u0026#39;truetype\u0026#39;); } body { background-color: #1d1d1d; font-family: monospace; margin: 20px; padding: 0; font-family: \u0026#39;MyCustomFont\u0026#39;, sans-serif; display: flex; flex-direction: column; min-height: 100vh; } h1 { opacity: 0; animation: fadeIn 1.5s ease-in forwards; color: #b4b4b4; display: inline; white-space:pre; } .loading { display: block; margin-bottom: 20px; } .typewriter { position: relative; width: 100%; max-width: 600px; } .typewriter .line { display: block; overflow: hidden; white-space: nowrap; margin-left: 10px; margin-top: -1px; color: #b4b4b4; font-weight: bold; letter-spacing: 2px; height: 1.5em; } @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;loading\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;LOADING\u0026lt;/h1\u0026gt; \u0026lt;h1 id=\u0026#34;loadingText\u0026#34; style=\u0026#34;font-size: 15px;\u0026#34;\u0026gt; - 系统启动中\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;typewriter\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;Neuro\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;Implanted\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;Machine for\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;Protecting\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;Human\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;突触连接：OFF\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;删除本机数据\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;网络连接\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;下载最新数据：完成\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;确认数据损失率：正常范围\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;确认神经元受损度：正常\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;确认神经元处理速度：正常\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;突触链接：ON\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;确认路由信息恢复率：正常范围\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;确认通信状态：良好\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;NIMPH系统：全部正常\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;数据自动保存\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;准备完毕\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; document.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, async function () { // 获取元素 const lines = Array.from(document.querySelectorAll(\u0026#39;.line\u0026#39;)) .filter(line =\u0026gt; line.dataset.text \u0026amp;\u0026amp; line.dataset.text.trim() !== \u0026#39;\u0026#39;); const loadingText = document.getElementById(\u0026#39;loadingText\u0026#39;); const lineEnd = lines[lines.length - 1]; // 定义加载动画状态 let dotCount = 0; let loadingInterval; // 启动加载动画 function startLoadingAnimation() { loadingInterval = setInterval(() =\u0026gt; { dotCount = (dotCount + 1) % 4; // 0-3循环 loadingText.textContent = \u0026#39; - 系统启动中\u0026#39; + \u0026#39;.\u0026#39;.repeat(dotCount); }, 500); // 每500ms更新一次 } // 停止加载动画 function stopLoadingAnimation() { clearInterval(loadingInterval); loadingText.textContent = \u0026#39; - 系统启动完成\u0026#39;; // 动画结束后显示完成状态 } // 打字动画函数 async function typeLine(line) { const fullText = line.dataset.text; line.textContent = \u0026#39;\u0026#39;; if (!fullText) return; const firstChar = fullText[0] || \u0026#39;|\u0026#39;; let currentIndex = 1; line.textContent = firstChar; return new Promise(resolve =\u0026gt; { function type() { if (currentIndex \u0026lt; fullText.length) { line.textContent = fullText.substring(0, currentIndex) + firstChar; currentIndex++; setTimeout(type, 20 + Math.random() * 15); } else { line.textContent = fullText; resolve(); } } setTimeout(type, 20); }); } // 执行流程：淡入动画 -\u0026gt; 加载动画 -\u0026gt; 打字动画 startLoadingAnimation(); // 先启动加载动画 // 等待淡入动画完成 await new Promise(resolve =\u0026gt; setTimeout(resolve, 1500)); // 处理除最后一行外的所有行 for (let i = 0; i \u0026lt; lines.length - 1; i++) { await typeLine(lines[i]); await new Promise(resolve =\u0026gt; setTimeout(resolve, 100)); } await new Promise(resolve =\u0026gt; setTimeout(resolve, 500)); await typeLine(lineEnd); // 所有打字动画完成后，停止加载动画 // stopLoadingAnimation(); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 实际使用版本： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;style\u0026gt; @font-face { font-family: \u0026#39;MyCustomFont\u0026#39;; src: url(\u0026#39;/font/MarukoGothicCJKjp-Regular.ttf\u0026#39;) format(\u0026#39;truetype\u0026#39;); } .loadingBox { position: fixed; justify-content: center; align-items: center; display: none; top: 0; left: 0; width: 100vw; height: 100vh; background-color: #1d1d1d; z-index: 9999; } .Bigbox { background-color: #1d1d1d; font-family: monospace; margin: 20px; padding: 0; font-family: \u0026#39;MyCustomFont\u0026#39;, sans-serif; display: flex; flex-direction: column; min-height: 100vh; } h1 { opacity: 0; animation: fadeIn 1.5s ease-in forwards; color: #b4b4b4; display: inline; white-space: pre; } .loading { display: block; margin-bottom: 20px; } .typewriter { position: relative; width: 100%; max-width: 600px; } .typewriter .line { display: block; overflow: hidden; white-space: nowrap; margin-left: 10px; margin-top: -1px; color: #b4b4b4; font-weight: bold; letter-spacing: 2px; height: 1.5em; } @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;loadingBox\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;Bigbox\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;loading\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;LOADING\u0026lt;/h1\u0026gt; \u0026lt;h1 id=\u0026#34;loadingText\u0026#34; style=\u0026#34;font-size: 15px;\u0026#34;\u0026gt; - 系统启动中\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;typewriter\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;Neuro\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;Implanted\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;Machine for\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;Protecting\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;Human\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;突触连接：OFF\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;删除本机数据\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;网络连接\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;下载最新数据：完成\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;确认数据损失率：正常范围\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;确认神经元受损度：正常\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;确认神经元处理速度：正常\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;突触链接：ON\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;确认路由信息恢复率：正常范围\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;确认通信状态：良好\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;NIMPH系统：全部正常\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;数据自动保存\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;准备完毕\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; document.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, async function () { // 使用类选择器获取元素 const loading = document.querySelector(\u0026#39;.loadingBox\u0026#39;); // 获取元素 const lines = Array.from(document.querySelectorAll(\u0026#39;.line\u0026#39;)) .filter(line =\u0026gt; line.dataset.text \u0026amp;\u0026amp; line.dataset.text.trim() !== \u0026#39;\u0026#39;); const loadingText = document.getElementById(\u0026#39;loadingText\u0026#39;);//此处根据id获取元素--纯扩展 const lineEnd = lines[lines.length - 1]; // 定义加载动画状态 let dotCount = 0; let loadingInterval; // 启动加载动画 function startLoadingAnimation() { loadingInterval = setInterval(() =\u0026gt; { dotCount = (dotCount + 1) % 4; // 0-3循环 loadingText.textContent = \u0026#39; - 系统启动中\u0026#39; + \u0026#39;.\u0026#39;.repeat(dotCount); }, 500); // 每500ms更新一次 } // 停止加载动画 function stopLoadingAnimation() { // clearInterval(loadingInterval); // loadingText.textContent = \u0026#39; - 系统启动完成\u0026#39;; // 动画结束后显示完成状态 // 创建并执行动画 const fadeOutAnimation = loading.animate([ { opacity: 1 }, { opacity: 0 } ], { duration: 800, fill: \u0026#39;forwards\u0026#39; }); // 动画结束后隐藏元素 fadeOutAnimation.finished.then(() =\u0026gt; { loading.style.display = \u0026#34;none\u0026#34;; sessionStorage.setItem(\u0026#39;visited\u0026#39;, \u0026#39;true\u0026#39;);//设置sessionStorage，标识为已被访问 }); } // 打字动画函数 async function typeLine(line) { const fullText = line.dataset.text; line.textContent = \u0026#39;\u0026#39;; if (!fullText) return; const firstChar = fullText[0] || \u0026#39;|\u0026#39;; let currentIndex = 1; line.textContent = firstChar; return new Promise(resolve =\u0026gt; { function type() { if (currentIndex \u0026lt; fullText.length) { line.textContent = fullText.substring(0, currentIndex) + firstChar; currentIndex++; setTimeout(type, 20 + Math.random() * 15); } else { line.textContent = fullText; resolve(); } } setTimeout(type, 20); }); } // 新增：等待所有资源加载完成（DOMContentLoaded不检测字体等资源是否加载完毕，所以需要另行检测） function waitForResourcesLoaded() { return new Promise(resolve =\u0026gt; { if (document.readyState === \u0026#39;complete\u0026#39;) { resolve(); } else { window.addEventListener(\u0026#39;load\u0026#39;, resolve); } }); } const isFirstVisit = !sessionStorage.getItem(\u0026#39;visited\u0026#39;); //定义判断是否为第一次访问 if (isFirstVisit) { loading.style.display = \u0026#34;block\u0026#34;; // 执行流程：淡入动画 -\u0026gt; 加载动画 -\u0026gt; 打字动画 startLoadingAnimation(); // 先启动加载动画 // 等待淡入动画完成 await new Promise(resolve =\u0026gt; setTimeout(resolve, 1500)); // 处理除最后一行外的所有行 for (let i = 0; i \u0026lt; lines.length - 1; i++) { await typeLine(lines[i]); await new Promise(resolve =\u0026gt; setTimeout(resolve, 100)); } // 等待所有资源加载完成 await waitForResourcesLoaded(); await typeLine(lineEnd); // 所有打字动画完成后，停止加载动画 await new Promise(resolve =\u0026gt; setTimeout(resolve, 800)); stopLoadingAnimation(); } else { console.log(\u0026#39;已被访问过，不再执行动画\u0026#39;); } }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 以下版本为不进行资源加载判断，会出现字体很久加载出来劣化体验感受的情况(可以保证绝对能访问) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;style\u0026gt; @font-face { font-family: \u0026#39;MyCustomFont\u0026#39;; src: url(\u0026#39;/font/MarukoGothicCJKjp-Regular.ttf\u0026#39;) format(\u0026#39;truetype\u0026#39;); } .loadingBox { position: fixed; justify-content: center; align-items: center; display: none; top: 0; left: 0; width: 100vw; height: 100vh; background-color: #1d1d1d; z-index: 9999; } .Bigbox { background-color: #1d1d1d; font-family: monospace; margin: 20px; padding: 0; font-family: \u0026#39;MyCustomFont\u0026#39;, sans-serif; display: flex; flex-direction: column; min-height: 100vh; } h1 { opacity: 0; animation: fadeIn 1.5s ease-in forwards; color: #b4b4b4; display: inline; white-space: pre; } .loading { display: block; margin-bottom: 20px; } .typewriter { position: relative; width: 100%; max-width: 600px; } .typewriter .line { display: block; overflow: hidden; white-space: nowrap; margin-left: 10px; margin-top: -1px; color: #b4b4b4; font-weight: bold; letter-spacing: 2px; height: 1.5em; } @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;loadingBox\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;Bigbox\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;loading\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;LOADING\u0026lt;/h1\u0026gt; \u0026lt;h1 id=\u0026#34;loadingText\u0026#34; style=\u0026#34;font-size: 15px;\u0026#34;\u0026gt; - 系统启动中\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;typewriter\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;Neuro\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;Implanted\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;Machine for\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;Protecting\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;Human\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;突触连接：OFF\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;删除本机数据\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;网络连接\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;下载最新数据：完成\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;确认数据损失率：正常范围\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;确认神经元受损度：正常\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;确认神经元处理速度：正常\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;突触链接：ON\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;确认路由信息恢复率：正常范围\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;确认通信状态：良好\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;NIMPH系统：全部正常\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;数据自动保存\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;准备完毕\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; document.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, async function () { // 使用类选择器获取元素 const loading = document.querySelector(\u0026#39;.loadingBox\u0026#39;); // 获取元素 const lines = Array.from(document.querySelectorAll(\u0026#39;.line\u0026#39;)) .filter(line =\u0026gt; line.dataset.text \u0026amp;\u0026amp; line.dataset.text.trim() !== \u0026#39;\u0026#39;); const loadingText = document.getElementById(\u0026#39;loadingText\u0026#39;);//此处更具id获取元素--纯扩展 const lineEnd = lines[lines.length - 1]; // 定义加载动画状态 let dotCount = 0; let loadingInterval; // 启动加载动画 function startLoadingAnimation() { loadingInterval = setInterval(() =\u0026gt; { dotCount = (dotCount + 1) % 4; // 0-3循环 loadingText.textContent = \u0026#39; - 系统启动中\u0026#39; + \u0026#39;.\u0026#39;.repeat(dotCount); }, 500); // 每500ms更新一次 } // 停止加载动画 function stopLoadingAnimation() { // clearInterval(loadingInterval); // loadingText.textContent = \u0026#39; - 系统启动完成\u0026#39;; // 动画结束后显示完成状态 // 创建并执行动画 const fadeOutAnimation = loading.animate([ { opacity: 1 }, { opacity: 0 } ], { duration: 800, fill: \u0026#39;forwards\u0026#39; }); // 动画结束后隐藏元素 fadeOutAnimation.finished.then(() =\u0026gt; { loading.style.display = \u0026#34;none\u0026#34;; sessionStorage.setItem(\u0026#39;visited\u0026#39;, \u0026#39;true\u0026#39;);//设置sessionStorage，标识为已被访问 }); } // 打字动画函数 async function typeLine(line) { const fullText = line.dataset.text; line.textContent = \u0026#39;\u0026#39;; if (!fullText) return; const firstChar = fullText[0] || \u0026#39;|\u0026#39;; let currentIndex = 1; line.textContent = firstChar; return new Promise(resolve =\u0026gt; { function type() { if (currentIndex \u0026lt; fullText.length) { line.textContent = fullText.substring(0, currentIndex) + firstChar; currentIndex++; setTimeout(type, 20 + Math.random() * 15); } else { line.textContent = fullText; resolve(); } } setTimeout(type, 20); }); } const isFirstVisit = !sessionStorage.getItem(\u0026#39;visited\u0026#39;); //定义判断是否为第一次访问 if (isFirstVisit) { loading.style.display = \u0026#34;block\u0026#34;; // 执行流程：淡入动画 -\u0026gt; 加载动画 -\u0026gt; 打字动画 startLoadingAnimation(); // 先启动加载动画 // 等待淡入动画完成 await new Promise(resolve =\u0026gt; setTimeout(resolve, 1500)); // 处理除最后一行外的所有行 for (let i = 0; i \u0026lt; lines.length - 1; i++) { await typeLine(lines[i]); await new Promise(resolve =\u0026gt; setTimeout(resolve, 100)); } await new Promise(resolve =\u0026gt; setTimeout(resolve, 500)); await typeLine(lineEnd); // 所有打字动画完成后，停止加载动画 await new Promise(resolve =\u0026gt; setTimeout(resolve, 800)); stopLoadingAnimation(); } else { console.log(\u0026#39;已被访问过，不再执行动画\u0026#39;); } }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 使用方法 将代码复制进 layouts/partials/head/custom.html (自行创建或复制)\n基本都加了备注，可以自行更改打印速率和字体大小，字体，内容等等。（看不懂的看下面）\n实现方法 一层容器 loadingBox 用于实现加载动画整体的淡入淡出效果。 二层容器 Bigbox 用于提供边距和字体等样式。 三层容器 loading 和 typewriter 分别承载各自内容。 loadingBox 的样式设置，设置背景色，宽高，z-index（深度，实现覆盖而非叠加）等。\u0026mdash;\u0026mdash;此处由于边距需要所以同样设置了背景色 Bigbox 的样式设置，设置背景色，宽高，字体，字体大小，边距 等。 typewriter 的样式设置，设置宽高，字体，字体大小，边距 等。 基本思路：在 DOMContentLoaded 事件中，判断是否为第一次访问，如果是，则将 loadingBox 显示出来，并执行下列动画，否则不执行动画并打印日志，利用简单的 css 控制大标题的透明度变化实现淡入，利用 js 拆分字体，通过拼接的方式以数组存储，利用定时器打印出来。 定义 fadeIn 动画，淡入效果。\u0026mdash;-实现 loading 内容的淡入效果。 定义 loadingInterval，用于实现加载动画。\u0026mdash;\u0026ndash;实现 loading 内容（后面三个点）的加载动画。 定义 stopLoadingAnimation， startLoadingAnimation，用于启动停止加载动画。 定义 typeLine，用于实现打字动画。 使用 isFirstVisit，通过 sessionStorage，用于判断是否为第一次访问。 定义 fadeOutAnimation，用于实现淡出动画（包含在 stopLoadingAnimation 中）。 衍生物 快速版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;style\u0026gt; @font-face { font-family: \u0026#39;MyCustomFont\u0026#39;; src: url(\u0026#39;/font/MarukoGothicCJKjp-Regular.ttf\u0026#39;) format(\u0026#39;truetype\u0026#39;); } body { background-color: #1d1d1d; font-family: monospace; margin: 20px; padding: 0; font-family: \u0026#39;MyCustomFont\u0026#39;, sans-serif; display: flex; flex-direction: column; min-height: 100vh; } h1 { opacity: 0; animation: fadeIn 1.5s ease-in forwards; color: #b4b4b4; margin-bottom: 30px; } .typewriter { position: relative; width: 100%; max-width: 600px; } .typewriter .line { display: block; overflow: hidden; white-space: nowrap; margin-left: 10px; margin-top: -1px; color: #b4b4b4; font-weight: bold; letter-spacing: 2px; height: 1.5em; } /* 为每一行设置不同的动画延迟 */ .typewriter .line:nth-child(1) { animation-delay: 0.5s; } .typewriter .line:nth-child(2) { animation-delay: 1.2s; } .typewriter .line:nth-child(3) { animation-delay: 1.9s; } .typewriter .line:nth-child(4) { animation-delay: 2.6s; } .typewriter .line:nth-child(5) { animation-delay: 3.1s; } .typewriter .line:nth-child(6) { animation-delay: 3.8s; } .typewriter .line:nth-child(7) { animation-delay: 4.5s; } .typewriter .line:nth-child(8) { animation-delay: 5.2s; } @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } } /* 状态指示器 */ .status { display: inline-block; width: 10px; height: 10px; border-radius: 50%; margin-left: 5px; background: #ff5555; vertical-align: middle; } .status.active { background: #55ff55; box-shadow: 0 0 8px rgba(85, 255, 85, 0.7); } /* 终端效果增强 */ .terminal-effect { position: absolute; width: 100%; height: 100%; top: 0; left: 0; background: repeating-linear-gradient(0deg, rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 1px, transparent 1px, transparent 2px); pointer-events: none; opacity: 0.2; } .system-complete { color: #55ff55; text-align: center; margin-top: 20px; opacity: 0; animation: fadeIn 1s 6s forwards; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;LOADING - 系统启动中...\u0026lt;/h1\u0026gt; \u0026lt;div class=\u0026#34;typewriter\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;Neuro\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;Implanted\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;Machine for\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;Protecting\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;Human\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;突触连接：OFF\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;删除本机数据\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;网络连接\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;下载最新数据：完成\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;确认数据损失率：正常范围\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;确认神经元受损度：正常\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;确认神经元处理速度：正常\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;突触链接：ON\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;确认路由信息恢复率：正常范围\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;确认通信状态：良好\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;NIMPH系统：全部正常\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34; data-text=\u0026#34;数据自动保存\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; document.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, function () { // 获取所有行元素 const lines = document.querySelectorAll(\u0026#39;.line\u0026#39;); const statusIndicator = document.querySelector(\u0026#39;.status\u0026#39;); const delays = [0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0, 2.1]; lines.forEach((line, index) =\u0026gt; { // 获取文本内容 const fullText = line.dataset.text; // 清空内容，准备开始打字 line.textContent = \u0026#39;\u0026#39;; // 设置延迟 setTimeout(() =\u0026gt; { // 获取首字母 const firstChar = fullText[0]; // 初始显示首字母（作为光标） line.textContent = firstChar; let currentIndex = 1; // 打字函数 function type() { if (currentIndex \u0026lt; fullText.length) { // 显示当前文本 + 首字母（作为光标） line.textContent = fullText.substring(0, currentIndex) + firstChar; currentIndex++; // 随机速度，模拟真实打字 const speed = 30 + Math.random() * 10; setTimeout(type, speed); } else { // 打字完成，显示完整文本 line.textContent = fullText; } } // 开始打字 setTimeout(type, 200); }, delays[index] * 1000); }); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 宽度实现方法（单纯 css 实现） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Test CSS\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; @font-face { font-family: \u0026#39;MyCustomFont\u0026#39;; src: url(\u0026#39;/font/MarukoGothicCJKjp-Regular.ttf\u0026#39;) format(\u0026#39;truetype\u0026#39;); } body { background-color: #1d1d1d; font-family: monospace; margin: 20px; padding: 0; font-family: \u0026#39;MyCustomFont\u0026#39;, sans-serif; } h1 { opacity: 0; animation: fadeIn 1.5s ease-in forwards; color:#b4b4b4; } .typewriter { position: relative; } .typewriter .line { display: block; overflow: hidden; white-space: nowrap; margin-left: 10px; margin-top:-1px; color:#b4b4b4; font-weight: bold; letter-spacing: 2px; /* border-right: #b4b4b4 15em solid; */ animation: typing 2s steps(60, end) forwards, blink-caret 0.45s step-end infinite; } /* 为每一行设置不同的动画延迟 */ .typewriter .line:nth-child(1) { animation-delay: 0.5s; width: 0; } .typewriter .line:nth-child(2) { animation-delay: 1.2s; width: 0; } .typewriter .line:nth-child(3) { animation-delay: 1.9s; width: 0; } .typewriter .line:nth-child(4) { animation-delay: 2.6s; width: 0; } .typewriter .line:nth-child(5) { animation-delay: 3.1s; width: 0; } .typewriter .line:nth-child(6) { animation-delay: 3.8s; width: 0; } .typewriter .line:nth-child(7) { animation-delay: 4.5s; width: 0; } .typewriter .line:nth-child(8) { animation-delay: 5.2s; width: 0; } @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } } @keyframes typing { from { width: 0 } to { width: 100% } } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;LOADING -系统启动中...\u0026lt;/h1\u0026gt; \u0026lt;div class=\u0026#34;typewriter\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34;\u0026gt;Neuro\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34;\u0026gt;Implanted\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34;\u0026gt;Machine for\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34;\u0026gt;Protecting\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34;\u0026gt;Human\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34;\u0026gt;突触连接：OFF\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34;\u0026gt;删除本机数据\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34;\u0026gt;网络连接\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 中间展开版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Test CSS\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; @font-face { font-family: \u0026#39;MyCustomFont\u0026#39;; src: url(\u0026#39;/font/MarukoGothicCJKjp-Regular.ttf\u0026#39;) format(\u0026#39;truetype\u0026#39;); } body { background-color: #1d1d1d; font-family: monospace; margin: 20px; padding: 0; font-family: \u0026#39;MyCustomFont\u0026#39;, sans-serif; } h1 { opacity: 0; animation: fadeIn 1.5s ease-in forwards; color: #b4b4b4; } .typewriter { position: relative; } .typewriter .line { display: flex; justify-content: center; margin-left: 10px; margin-top: -1px; color: #b4b4b4; font-weight: bold; letter-spacing: 2px; overflow: hidden; } .typewriter .char { opacity: 0; transform: scale(0); animation: popIn 0.3s forwards; } /* 为每一行设置不同的动画延迟 */ .typewriter .line:nth-child(1) { animation-delay: 0.5s; } .typewriter .line:nth-child(2) { animation-delay: 1.2s; } .typewriter .line:nth-child(3) { animation-delay: 1.9s; } .typewriter .line:nth-child(4) { animation-delay: 2.6s; } .typewriter .line:nth-child(5) { animation-delay: 3.1s; } .typewriter .line:nth-child(6) { animation-delay: 3.8s; } .typewriter .line:nth-child(7) { animation-delay: 4.5s; } .typewriter .line:nth-child(8) { animation-delay: 5.2s; } @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } } @keyframes popIn { 0% { opacity: 0; transform: scale(0); } 100% { opacity: 1; transform: scale(1); } } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;LOADING -系统启动中...\u0026lt;/h1\u0026gt; \u0026lt;div class=\u0026#34;typewriter\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;line\u0026#34; data-text=\u0026#34;Neuro\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;line\u0026#34; data-text=\u0026#34;Implanted\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;line\u0026#34; data-text=\u0026#34;Machine for\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;line\u0026#34; data-text=\u0026#34;Protecting\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;line\u0026#34; data-text=\u0026#34;Human\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;line\u0026#34; data-text=\u0026#34;突触连接：OFF\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;line\u0026#34; data-text=\u0026#34;删除本机数据\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;line\u0026#34; data-text=\u0026#34;网络连接\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; document.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, function () { const lines = document.querySelectorAll(\u0026#39;.line\u0026#39;); lines.forEach((line, lineIndex) =\u0026gt; { const text = line.getAttribute(\u0026#39;data-text\u0026#39;); line.innerHTML = \u0026#39;\u0026#39;; // 创建字符元素 const chars = text.split(\u0026#39;\u0026#39;); chars.forEach((char, charIndex) =\u0026gt; { const charElement = document.createElement(\u0026#39;span\u0026#39;); charElement.className = \u0026#39;char\u0026#39;; charElement.textContent = char; // 计算每个字符的动画延迟 - 从中间向两边 const middle = chars.length / 2; const distanceFromMiddle = Math.abs(charIndex - middle); const delay = lineIndex * 0.7 + distanceFromMiddle * 0.1; charElement.style.animationDelay = `${delay}s`; line.appendChild(charElement); }); }); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","date":"2025-07-05T12:02:23+08:00","permalink":"https://axppk.github.io/p/%E4%BB%BFnikki%E8%81%94%E5%8A%A8%E5%B0%BC%E5%B0%94%E7%9A%84%E5%90%AF%E5%8A%A8%E5%8A%A8%E7%94%BB/","title":"仿Nikki联动尼尔的启动动画"},{"content":"前言 首先介绍一下 Hugo 使用样式文件的基本优先级，Hugo 会优先使用网站根目录下 layouts\\ 文件夹中的样式文件，之后使用模板中的样式文件，以 Stack 主题中的文章详情样式为例，它使用的模板是 themes\\hugo-theme-stack\\layouts\\partials\\article\\components\\details.html ，如果想要修改样式，则需要在同样的目录下创建同样的样式文件将其覆盖，即在 layouts\\partials\\article\\components\\ 目录下创建 details.html 文件，并将源文件中的代码复制过来。\nPS：其实我一直认为它是合并，直到我调整鼠标样式时修改了 details.html 文件，才发现原来是覆盖。 缺少的文件手动创建或主题内复制。\n更换字体 下载字体文件，如 MarukoGothicCJKjp-Regular.ttf 解压至对应的字体目录路径( assets/font ) 按 layouts/partials/footer/custom.html 路径创建配置文件并拷贝以下代码 虽然乌龙了，但是晓得了代码块下划线怎么用 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;style\u0026gt; @font-face { font-family: \u0026#39;字体名\u0026#39;; src: url({{ (resources.Get \u0026#34;font/字体文件名（带后缀）\u0026#34;).Permalink }}) format(\u0026#39;truetype\u0026#39;); } :root { --base-font-family: \u0026#39;字体名\u0026#39;; --code-font-family: \u0026#39;字体名\u0026#39;; } \u0026lt;/style\u0026gt; 上为原代码将导致字体文件无法加载， custom 文件报错（以下代码仅本地可用，服务器将导致字体丢失\u0026mdash;原因为两者一个是动态引用一个是静态引用）。 1 2 3 4 5 6 7 8 9 10 11 12 /_ 字体 _/ @font-face { font-family: \u0026#39;MarukoGothicCJKjp-Regular\u0026#39;; src: url(\u0026#39;/font/MarukoGothicCJKjp-Regular.ttf\u0026#39;) format(\u0026#39;truetype\u0026#39;); } :root { --base-font-family: \u0026#39;MarukoGothicCJKjp-Regular\u0026#39;, sans-serif; --code-font-family: \u0026#39;MarukoGothicCJKjp-Regular\u0026#39;, monospace; } /_ 字体 _/ 更换鼠标样式 逆天指针卡了我两个小时，也是够了，折腾了半天希望实现动态指针，通过网上找到的解析.ani 文件未.cur 并逐帧播放的方法，最终实现了动态指针效果。\nBut！！！效果不佳，和 ppt 一样有明显卡顿感，但确实能行，并且会和原本的动态鼠标样式混淆，所以还是放弃了，转而采用传统的静态图标的方法。\nBut！！！奇葩的情况出现了，一般鼠标指针都为.cur 或.ani 格式，所以在替换时并没有太注意，结果出现了问题，指针在我的浏览器巨大无比，经过漫长的排查，最后发现调整成.png 格式就恢复正常了。\n贴一下使用的链接：图片转换器\n步骤：\n鼠标指针图片放在 static/mouse 文件夹下 修改 assets/scss/custom.scss 文件，填充以下代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 【Stack 主题鼠标样式写法】 // default 光标图片 body, html, .article-content img { cursor: url(../mouse/默认光标图片名), auto !important; } // pointer 光标图片 a:hover, button:hover, .copyCodeButton:hover, #dark-mode-toggle { cursor: url(../mouse/指针光标图片名), auto; } // text 光标图片 input:hover, .site-description, .article-subtitle, .article-content span, .article-content li, .article-content p { cursor: url(../mouse/文本光标图片名), auto; } 显示文章更新时间 配置文件 hugo.yaml 下添加以下代码 1 2 3 4 5 6 7 8 9 # 更新时间：优先读取 git 时间 -\u0026gt; git 时间不存在，就读取本地文件修改时间 frontmatter: lastmod: - :git - :fileModTime # 允许获取 Git 信息 enableGitInfo: true 修改 github action 文件 .github/workflows/xxx.yaml ，在运行 hugo -D 命令的 step 前加入以下配置 1 2 3 4 5 6 7 - name: Git Configuration run: | git config --global core.quotePath false git config --global core.autocrlf false git config --global core.safecrlf true git config --global core.ignorecase false 若想在文章开头就显示更新时间，修改 layouts/partials/article/components/details.html 文件，添加以下代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;div class=\u0026#34;article-details\u0026#34;\u0026gt; ... \u0026lt;footer class=\u0026#34;article-time\u0026#34;\u0026gt; ... \u0026lt;!-- 更新时间 --\u0026gt; {{- if ne .Lastmod .Date -}} \u0026lt;div class=\u0026#34;article-lastmod\u0026#34;\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;clock\u0026#34; }} \u0026lt;time\u0026gt; {{ .Lastmod.Format ( or .Site.Params.dateFormat.lastUpdated \u0026#34;Jan 02, 2006 15:04 MST\u0026#34; ) }} \u0026lt;/time\u0026gt; \u0026lt;/div\u0026gt; {{- end -}} .... \u0026lt;/footer\u0026gt; ... \u0026lt;/div\u0026gt; 显示文章字数统计 在 layouts\\partials\\article\\components\\details.html 文件中添加以下代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 ... \u0026lt;footer class=\u0026#34;article-time\u0026#34;\u0026gt; {{ if $showDate }} \u0026lt;div\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;date\u0026#34; }} \u0026lt;time class=\u0026#34;article-time--published\u0026#34;\u0026gt; {{- .Date | time.Format (or .Site.Params.dateFormat.published \u0026#34;Jan 02, 2006\u0026#34;) -}} \u0026lt;/time\u0026gt; \u0026lt;/div\u0026gt; {{ end }} \u0026lt;!-- 在此插入以下代码 --\u0026gt; {{ if $showReadingTime }} \u0026lt;div\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;wordcount\u0026#34; }} \u0026lt;time class=\u0026#34;article-time--reading\u0026#34;\u0026gt; {{ T \u0026#34;article.wordCount\u0026#34; .WordCount }} \u0026lt;/time\u0026gt; \u0026lt;/div\u0026gt; {{ end }} \u0026lt;!-- 在此结束 --\u0026gt; {{ if $showReadingTime }} \u0026lt;div\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;clock\u0026#34; }} \u0026lt;time class=\u0026#34;article-time--reading\u0026#34;\u0026gt; {{ T \u0026#34;article.readingTime\u0026#34; .ReadingTime }} \u0026lt;/time\u0026gt; \u0026lt;/div\u0026gt; {{ end }} \u0026lt;/footer\u0026gt; {{ end }} ... 在 i18n\\en.toml 文件中的 article: 类下添加以下代码 1 2 3 # 以下为新增代码 wordCount: other: \u0026#34;本文共 {{ .Count }} 字\u0026#34; 在 assets\\icons\\ 文件夹下创建 wordcount.svg\n本站使用图标\n1 2 3 4 5 6 7 8 9 \u0026lt;svg xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; class=\u0026#34;icon icon-tabler icon-tabler-text-count\u0026#34; width=\u0026#34;56\u0026#34; height=\u0026#34;56\u0026#34; viewBox=\u0026#34;0 0 24 24\u0026#34; stroke-width=\u0026#34;2\u0026#34; stroke=\u0026#34;currentColor\u0026#34; fill=\u0026#34;none\u0026#34; stroke-linecap=\u0026#34;round\u0026#34; stroke-linejoin=\u0026#34;round\u0026#34;\u0026gt; \u0026lt;path stroke=\u0026#34;none\u0026#34; d=\u0026#34;M0 0h24v24H0z\u0026#34;/\u0026gt; \u0026lt;!-- 纸张背景 --\u0026gt; \u0026lt;rect x=\u0026#34;4\u0026#34; y=\u0026#34;4\u0026#34; width=\u0026#34;16\u0026#34; height=\u0026#34;16\u0026#34; rx=\u0026#34;2\u0026#34; ry=\u0026#34;2\u0026#34; /\u0026gt; \u0026lt;path d=\u0026#34;M8 8h8\u0026#34; /\u0026gt; \u0026lt;path d=\u0026#34;M8 12h8\u0026#34; /\u0026gt; \u0026lt;path d=\u0026#34;M8 16h8\u0026#34; /\u0026gt; \u0026lt;/svg\u0026gt; 注意！stack 主题用的适量图标均为无填充，粗线条构建，所以如果发现自己找来的图标不符合要求，不要傻傻的去试图更改颜色适配！！！ 友链、归档多列显示 修改 assets/scss/custom.scss 文件，引入以下 css 样式代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @media (min-width: 1024px) { .article-list--compact { display: grid; // 目前是两列，如需三列，则后面再加一个1fr，以此类推 grid-template-columns: 1fr 1fr 1fr; background: none; box-shadow: none; gap: 1rem; article { background: var(--card-background); border: none; box-shadow: var(--shadow-l2); margin-bottom: 8px; margin-right: 8px; border-radius: 16px; } } } 文章目录自动折叠 将以下代码复制到 layouts/partials/footer/custom.html 文件中 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 \u0026lt;style\u0026gt; #TableOfContents \u0026gt; ul, ol { ul, ol { display: none; } .open { display: block; } } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; function initTocHide() { // 判断是否存在文章目录 let toc = document.querySelector(\u0026#34;.widget--toc\u0026#34;); if (!toc) { return; } // 监听滚动 window.addEventListener(\u0026#39;scroll\u0026#39;, function() { //清除class值 let openUl = document.querySelectorAll(\u0026#34;.open\u0026#34;); if (openUl.length \u0026gt; 0) { openUl.forEach((ul) =\u0026gt; { ul.classList.remove(\u0026#34;open\u0026#34;) }) } // 获取active-class let currentLi = document.querySelector(\u0026#34;.active-class\u0026#34;); if (!currentLi) { return } // 展示子ul if (currentLi.children.length \u0026gt; 1) { currentLi.children[1].classList.add(\u0026#34;open\u0026#34;) } // 展示父ul let ul = currentLi.parentElement; do { ul.classList.add(\u0026#34;open\u0026#34;); ul = ul.parentElement.parentElement } while (ul !== undefined \u0026amp;\u0026amp; (ul.localName === \u0026#39;ul\u0026#39; || ul.localName === \u0026#39;ol\u0026#39;)) }); } initTocHide() \u0026lt;/script\u0026gt; 文章就会默认隐藏子目录，等滚动到对应的目录后，才会将子目录进行展示。 动态头像 准备合适大小的 gif 图片，如 你的名字.gif，将其放入 static/img 文件夹下（gif 过大将导致重影）\nhugo.yaml 文件中更改配置 local 改为 flase 和 avatar 改为 你的名字.gif\n补充：静态头像放在 assets/img 下（和原主题保持一致），此处放在 static/img 下是为了避开 Hugo 默认的资源处理（static 目录下不会被处理）。\nStack 主题默认会在 assets/ 或 static/ 中查找头像文件，并通过 Hugo Pipes 处理（添加哈希值后缀\u0026mdash;资源指纹，处理压缩\u0026mdash;方便缓存，提高缓存速率）。\nlocal 设为 false 时，头像也可以直接采用 url 路径，如 avatar: \u0026quot;https://xxx.com/your-avatar.png\u0026quot;。\n动态背景 樱花飞舞背景\n下载【sakura.js】(Ctrl + S 保存)，并放到 assets/background 文件夹下\n在 layouts/partials/footer/custom.html 中，引入以下代码\n1 \u0026lt;script src={{ (resources.Get \u0026#34;background/sakura.js\u0026#34;).Permalink }}\u0026gt;\u0026lt;/script\u0026gt; 代码收缩 准备一张向下展开图片(Ctrl+S 保存)，放到 assets/icons 目录下\n将以下代码复制进 layouts/partials/footer/custom.html (文件不存在则自行创建)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 \u0026lt;style\u0026gt; .highlight { /* 你可以根据需要调整这个高度 */ max-height: 400px; overflow: hidden; } .code-show { max-height: none !important; } .code-more-box { width: 100%; padding-top: 78px; background-image: -webkit-gradient(linear, left top, left bottom, from(rgba(255, 255, 255, 0)), to(#fff)); position: absolute; left: 0; right: 0; bottom: 0; z-index: 1; } .code-more-btn { display: block; margin: auto; width: 44px; height: 22px; background: #f0f0f5; border-top-left-radius: 8px; border-top-right-radius: 8px; padding-top: 6px; cursor: pointer; } .code-more-img { cursor: pointer !important; display: block; margin: auto; width: 22px; height: 16px; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; //代码收缩 function initCodeMoreBox() { let codeBlocks = document.querySelectorAll(\u0026#34;.highlight\u0026#34;); if (!codeBlocks) { return; } codeBlocks.forEach(codeBlock =\u0026gt; { // 校验是否overflow if (codeBlock.scrollHeight \u0026lt;= codeBlock.clientHeight) { return; } // 元素初始化 // codeMoreBox let codeMoreBox = document.createElement(\u0026#39;div\u0026#39;); codeMoreBox.classList.add(\u0026#39;code-more-box\u0026#39;); // codeMoreBtn let codeMoreBtn = document.createElement(\u0026#39;span\u0026#39;); codeMoreBtn.classList.add(\u0026#39;code-more-btn\u0026#39;); codeMoreBtn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { codeBlock.classList.add(\u0026#39;code-show\u0026#39;); codeMoreBox.style.display = \u0026#39;none\u0026#39;; // 触发resize事件，重新计算目录位置 window.dispatchEvent(new Event(\u0026#39;resize\u0026#39;)) }); // img let img = document.createElement(\u0026#39;img\u0026#39;); img.classList.add(\u0026#39;code-more-img\u0026#39;); // 使用Hugo模板语法获取图片路径 img.src = \u0026#39;{{ (resources.Get \u0026#34;icons/codeMore.png\u0026#34;).Permalink }}\u0026#39;; // 元素添加 codeMoreBtn.appendChild(img); codeMoreBox.appendChild(codeMoreBtn); codeBlock.appendChild(codeMoreBox); }); } //代码收缩 initCodeMoreBox(); \u0026lt;/script\u0026gt; 返回顶部 准备一张返回顶部图片(Ctrl+S 保存)，放到 assets/icons\n将以下代码复制到 layouts/partials/footer/custom.html 文件中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 \u0026lt;style\u0026gt; #backTopBtn { display: none; position: fixed; bottom: 30px; z-index: 99; cursor: pointer; width: 30px; height: 30px; background-image: url({{ (resources.Get \u0026#34;icons/backTop.svg\u0026#34;).Permalink }}); } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; /** * 滚动回顶部初始化 */ function initScrollTop() { let rightSideBar = document.querySelector(\u0026#34;.right-sidebar\u0026#34;); if (!rightSideBar) { return; } // 添加返回顶部按钮到右侧边栏 let btn = document.createElement(\u0026#34;div\u0026#34;); btn.id = \u0026#34;backTopBtn\u0026#34;; btn.onclick = backToTop rightSideBar.appendChild(btn) // 滚动监听 window.onscroll = function() { // 当网页向下滑动 20px 出现\u0026#34;返回顶部\u0026#34; 按钮 if (document.body.scrollTop \u0026gt; 20 || document.documentElement.scrollTop \u0026gt; 20) { btn.style.display = \u0026#34;block\u0026#34;; } else { btn.style.display = \u0026#34;none\u0026#34;; } }; } /** * 返回顶部 */ function backToTop(){ window.scrollTo({ top: 0, behavior: \u0026#34;smooth\u0026#34; }) } initScrollTop(); \u0026lt;/script\u0026gt; 点击特效 获取网上下载的点击特效\n创建新的 js 文件，如 click.js放在 assets/click-effect 文件夹下\n将以下代码复制进 click.js 文件中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 /** * 鼠标点击和长按特效函数 * 创建一个全屏canvas，实现点击和长按的粒子动画效果 */ function clickEffect() { let balls = []; // 存储所有粒子的数组 let longPressed = false; // 是否长按的标志 let longPress; // 长按定时器 let multiplier = 0; // 长按乘数，影响粒子大小和数量 let width, height; // canvas宽高 let origin; // 原点位置 let normal; // 法线向量 let ctx; // canvas上下文 // 粒子颜色数组 const colours = [\u0026#34;#F73859\u0026#34;, \u0026#34;#14FFEC\u0026#34;, \u0026#34;#00E0FF\u0026#34;, \u0026#34;#FF99FE\u0026#34;, \u0026#34;#FAF15D\u0026#34;]; // 创建全屏canvas元素并添加到页面 const canvas = document.createElement(\u0026#34;canvas\u0026#34;); document.body.appendChild(canvas); canvas.setAttribute(\u0026#34;style\u0026#34;, \u0026#34;width: 100%; height: 100%; top: 0; left: 0; z-index: 99999; position: fixed; pointer-events: none;\u0026#34;); // 创建鼠标指针元素 const pointer = document.createElement(\u0026#34;span\u0026#34;); pointer.classList.add(\u0026#34;pointer\u0026#34;); document.body.appendChild(pointer); // 检查浏览器支持 if (canvas.getContext \u0026amp;\u0026amp; window.addEventListener) { ctx = canvas.getContext(\u0026#34;2d\u0026#34;); updateSize(); window.addEventListener(\u0026#39;resize\u0026#39;, updateSize, false); loop(); // 鼠标按下事件 - 点击或长按的开始 window.addEventListener(\u0026#34;mousedown\u0026#34;, function(e) { // 点击时创建10-20个粒子 pushBalls(randBetween(10, 20), e.clientX, e.clientY); document.body.classList.add(\u0026#34;is-pressed\u0026#34;); // 设置长按定时器(500ms) - 可调整长按检测时间 longPress = setTimeout(function(){ document.body.classList.add(\u0026#34;is-longpress\u0026#34;); longPressed = true; }, 500); // 长按检测时间 - 可调整持续时间 }, false); // 鼠标释放事件 - 点击或长按的结束 window.addEventListener(\u0026#34;mouseup\u0026#34;, function(e) { clearInterval(longPress); if (longPressed == true) { document.body.classList.remove(\u0026#34;is-longpress\u0026#34;); // 长按结束时创建更多粒子(50-100 + multiplier) pushBalls(randBetween(50 + Math.ceil(multiplier), 100 + Math.ceil(multiplier)), e.clientX, e.clientY); longPressed = false; } document.body.classList.remove(\u0026#34;is-pressed\u0026#34;); }, false); // 鼠标移动事件 - 更新指针位置 window.addEventListener(\u0026#34;mousemove\u0026#34;, function(e) { let x = e.clientX; let y = e.clientY; pointer.style.top = y + \u0026#34;px\u0026#34;; pointer.style.left = x + \u0026#34;px\u0026#34;; }, false); } else { console.log(\u0026#34;canvas or addEventListener is unsupported!\u0026#34;); } /** * 更新canvas尺寸，适应窗口变化 */ function updateSize() { // 高分辨率渲染 canvas.width = window.innerWidth * 2; canvas.height = window.innerHeight * 2; canvas.style.width = window.innerWidth + \u0026#39;px\u0026#39;; canvas.style.height = window.innerHeight + \u0026#39;px\u0026#39;; ctx.scale(2, 2); width = window.innerWidth; height = window.innerHeight; origin = { x: width / 2, y: height / 2 }; normal = { x: width / 2, y: height / 2 }; } /** * 粒子类 - 表示特效中的单个粒子 */ class Ball { constructor(x = origin.x, y = origin.y) { this.x = x; // 粒子x坐标 this.y = y; // 粒子y坐标 this.angle = Math.PI * 2 * Math.random(); // 粒子发射角度 // 粒子速度乘数 - 长按会产生更大更快的粒子 if (longPressed == true) { this.multiplier = randBetween(10 + multiplier, 12 + multiplier); } else { this.multiplier = randBetween(6, 12); } // 粒子速度分量 this.vx = (this.multiplier + Math.random() * 0.5) * Math.cos(this.angle); this.vy = (this.multiplier + Math.random() * 0.5) * Math.sin(this.angle); // 粒子初始半径 - 可调整粒子大小 this.r = randBetween(4, 6) + 2 * Math.random(); // 可调整粒子大小 // 随机选择粒子颜色 this.color = colours[Math.floor(Math.random() * colours.length)]; } /** * 更新粒子位置和属性 */ update() { this.x += this.vx - normal.x; this.y += this.vy - normal.y; normal.x = -2 / window.innerWidth * Math.sin(this.angle); normal.y = -2 / window.innerHeight * Math.cos(this.angle); // 粒子半径减小 - 控制粒子消失速度(持续时间) this.r -= 0.3; // 可调整粒子消失速度(持续时间) // 速度衰减 this.vx *= 0.9; this.vy *= 0.9; } } /** * 创建指定数量的粒子 * @param {number} count - 粒子数量 * @param {number} x - 起始x坐标 * @param {number} y - 起始y坐标 */ function pushBalls(count = 1, x = origin.x, y = origin.y) { for (let i = 0; i \u0026lt; count; i++) { balls.push(new Ball(x, y)); } } /** * 生成指定范围内的随机整数 * @param {number} min - 最小值 * @param {number} max - 最大值 * @returns {number} - 随机整数 */ function randBetween(min, max) { return Math.floor(Math.random() * max) + min; } /** * 动画循环 - 每一帧更新和绘制所有粒子 */ function loop() { // 清空画布 ctx.fillStyle = \u0026#34;rgba(255, 255, 255, 0)\u0026#34;; ctx.clearRect(0, 0, canvas.width, canvas.height); // 绘制并更新所有粒子 for (let i = 0; i \u0026lt; balls.length; i++) { let b = balls[i]; if (b.r \u0026lt; 0) continue; ctx.fillStyle = b.color; ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2, false); ctx.fill(); b.update(); } // 长按乘数更新 if (longPressed == true) { multiplier += 0.2; } else if (!longPressed \u0026amp;\u0026amp; multiplier \u0026gt;= 0) { multiplier -= 0.4; } // 移除离开画布或半径小于0的粒子 removeBall(); // 请求下一帧动画 requestAnimationFrame(loop); } /** * 移除超出边界或不可见的粒子 */ function removeBall() { for (let i = 0; i \u0026lt; balls.length; i++) { let b = balls[i]; if (b.x + b.r \u0026lt; 0 || b.x - b.r \u0026gt; width || b.y + b.r \u0026lt; 0 || b.y - b.r \u0026gt; height || b.r \u0026lt; 0) { balls.splice(i, 1); } } } } // 调用特效函数 clickEffect(); 和背景的 js 一样在 layouts/partials/footer/custom.html 中引入 1 \u0026lt;script src={{ (resources.Get \u0026#34;click-effect/click.js\u0026#34; ).Permalink }}\u0026gt;\u0026lt;/script\u0026gt; 这样就实现了鼠标点击和长按的粒子动画效果，该 js 已被添加注释，可以根据注释改动参数和效果。 评论系统 目前博客使用的是 giscus 评论系统（这个主题内置了多个评论系统）。 直接跟着官方文档走即可giscus\n最后改一下配置文件就行了。(想进一步改动的可以了解下，改动 giscus.html 即可)\n小 BUG 处理 github action 提示 you can try to increase the ’timeout’ config setting.\n由于 github action 编译时间超过了 hugo 允许的编译时间导致的提交失败（action 中有错误提示和解决方法）\n在如图位置添加 time：6000s 即可（数值自行调整）\n参考链接\n","date":"2025-07-02T16:35:37+08:00","permalink":"https://axppk.github.io/p/%E5%8D%9A%E5%AE%A2%E6%94%B9%E9%80%A0%E8%AE%B0%E5%BD%95/","title":"博客改造记录"},{"content":"前言 首先介绍用到的工具：\nHugo：一个静态网站生成器，内置大量好看的主题，可以将 Markdown 文件转换为 HTML 文件，应该是开源项目，使用 go 语言编写（Google 开发的语言\u0026ndash;大概）。 简而言之，这是一个框架，可以快速搭建个人博客。\nGithub：一个代码托管平台，可以托管代码，提供版本控制，可以与 Hugo 配合使用。 简而言之，这是一个开源的远程仓库云端存储，可以存储代码，提供版本控制追踪，可以用于托管部署我们的 Hugo 网站。\nGit Cmd：一个 Git 命令行工具，可以与 Github 配合使用，可以方便地管理执行 Git 命令代码。\n部署步骤 安装 Hugo 下载 Hugo 压缩包，解压到任意目录，比如 C:\\Hugo。 配置 Hugo 打开命令行工具，切换到 Hugo 目录，输入以下命令： 1 hugo new site dev 该命令用于创建一个名为 dev 的网站目录。 1 cd dev 进入 dev 目录。 安装 Hugo 主题 下载喜欢的 Hugo 主题，解压到 themes 目录，即 dev\\themes。 复制 exampleSite 文件夹下的 content 与 hugo.yaml 文件到 dev 目录。 打开 hugo.yaml 文件，修改 baseurl 与 theme 选项。\n如图所示：baseurl对应的是网站的根目录（即网站的域名此处应为 yourusername.github.io如果按接下里的流程走的话），theme对应的是主题名称。\n补充：此处的 hugo.yaml 文件是 Hugo 的配置文件，同样的还有另一种 config.toml 文件，同为配置文件，可以根据自己的需求进行修改。 安装 Git 下载 Git 压缩包，安装到任意目录，比如 C:\\Git。 配置 Git 打开 Git 命令行工具，输入以下命令： 1 git init 此举是 Git 版本控制系统中的一个基本命令，它的主要作用是在指定目录下创建一个新的 Git 仓库。这个命令会初始化一个空的仓库，为项目的版本控制和代码管理奠定基础。\n补充：执行 git init 后，Git 会在当前目录下创建一个名为 .git 的隐藏文件夹。这个文件夹是非常重要的，因为它包含了版本控制系统的所有必要信息，如配置文件、分支、标签等。这个文件夹是 Git 仓库的心脏，没有它，版本控制就无法进行，git 开头代码将报错。\n1 2 git config --global user.name \u0026#34;your name\u0026#34; git config --global user.email \u0026#34;your email\u0026#34; 将 your name 和 your email 替换为你的真实姓名和邮箱。\n此举是首次执行 Git 命令，会在你的电脑上创建一个全局配置，之后就表示你这台机器上所有的 Git 仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和 Email 地址。\n补充： 查看全局配置代码：git config -l（这是 l 不是 1）\n补充 Git （自动部署需要） 新建 .gitignore 文件，添加忽略规则，存放在项目根目录下（此处即 dev 目录）。 新建 deploy.yaml 文件，添加自动部署脚本，存放在项目根目录(dev 目录)下的 .github/workflows 目录下(该目录需自己创建)。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 name: deploy # 代码提交到main分支时触发github action on: push: branches: - main jobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 with: fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;latest\u0026#34; extended: true - name: Build Web run: hugo -D - name: Deploy Web uses: peaceiris/actions-gh-pages@v4 with: PERSONAL_TOKEN: ${{ secrets.变量名 }}----需要修改 EXTERNAL_REPOSITORY: 用户名/博客域名（yourusername.github.io）------需要修改 PUBLISH_BRANCH: main PUBLISH_DIR: ./public commit_message: auto deploy 创建 Github 仓库（重点） 登录 Github 网站，点击右上角的 + 号，选择 New repository，输入仓库名称，点击 Create repository。\n此处重点在于仓库名称的设置：\n创建一个部署 Hugo 网站的仓库，设置为公开仓库，并命名为 yourusername.github.io，其中 yourusername 是你的 Github 用户名。 （注意：仓库名称应为 yourusername.github.io，否则可能导致后期混乱。）\n创建一个存储主要资源的仓库，设置为私有仓库，并命名为 yourusername.github.io.source，其中 yourusername 是你的 Github 用户名。 （此处名称随意，但应与网站仓库名称不同且便于记忆。）\n获取 token （自动部署需要） 点击个人头像，选择 Settings（设置），选择 Developer settings（开发者设置），选择 Personal access tokens（个人访问令牌），点击 Generate new token（生成新令牌，两个都可以）。\n输入 Token description（令牌描述），日期选择 No expiration（永不过期），勾选 repo（仓库），workflow（工作流），点击 Generate token（生成令牌）。\n复制生成的 ACCESS_TOKEN 值（该值只会显示一次，请务必妥善保管），点击 Close 按钮。\n进入刚刚创建的 yourusername.github.io.source 仓库，点击 Settings，选择 Secrets（机密），点击 New repository secret（新增机密），输入 ACCESS_TOKEN（刚复制的令牌值），点击 Add secret（添加机密）。\n此处的 ACCESS_TOKEN 即为 Github 网站生成的个人访问令牌，用于自动部署。\n部署网站 切换到 dev 目录，输入以下命令： 1 hugo -D 该命令用于将 Markdown 文件转换为 HTML 文件，并将生成的 HTML 文件保存在 dev\\public 目录下。 (hugo -D 是 Hugo 的编译命令，-D 参数表示将生成的 HTML 文件放入 public 目录下，方便部署。) 1 git branch -M main 该命令用于将当前分支重命名为 main，因为 Github 网站的默认分支名为 main。 （git branch -M为重命名分支命令，-M参数为强制重命名，main是新分支名） 1 2 git remote add origin https://github.com/yourusername/yourusername.github.io.git git remote add source https://github.com/yourusername/yourusername.github.io.source.git 该命令用于将本地仓库与 Github 仓库建立联系，并将本地仓库推送到 Github 仓库。 （git remote add为添加远程仓库命令，origin和是部署博客展示的远程仓库名称，https://github.com/yourusername/yourusername.github.io.git是远程仓库的地址，source是存储主要资源的远程仓库名称，https://github.com/yourusername/yourusername.github.io.source.git是远程仓库的地址\u0026mdash;-分为两个仓库，一个用于部署博客展示，一个用于存储主要资源） 1 git add . 该命令用于将所有修改的文件添加到暂存区（.不可省略且此命令必须在 git commit 命令之前否则推送上去的仍然是旧文件）。 1 git commit -m \u0026#34;save local changes before update\u0026#34; 该命令用于将暂存区中的更改提交到本地的仓库，并添加消息，引号中消息根据内容自定义。 1 2 git push origin main git push source main 该命令用于将本地仓库推送到 Github 仓库的 main 分支。 （ git push 为推送命令， -u 参数为设置默认推送分支， origin 和 source 是远程仓库的名称， main 是分支名） 等待几分钟，访问 https://yourusername.github.io 即可看到部署成功的网站。 扩展 1 git remote -v 验证远程库配置是否正确 1 git branch -a 显示所有本地和远程分支（*代表当前分支\u0026ndash;红字代表远程分支） 1 git log 查看提交历史(可以通过此处获取 hash 值，用于回退版本\u0026mdash;慎用) 1 hugo server -D 启动本地服务器，实时预览网站内容（-D 参数表示将生成的 HTML 文件放入 public 目录下，方便部署(写博客)。） 1 2 3 4 5 6 @echo off git add . git commit -m \u0026#34;update Blog\u0026#34; git push source main echo Blog Finished！ pause 一键部署脚本（将以上命令写入脚本（.bat）文件，双击运行即可\u0026mdash;适用于 windows 系统） 1 2 3 4 5 6 7 @echo off set /p postname=\u0026#34;输入文章名称（不需要加.md）: \u0026#34; hugo new \u0026#34;post/%postname%/index.md\u0026#34; echo 成功创建：content\\post\\%postname%\\index.md pause 一键创建文章脚本（将以上命令写入脚本（.bat）文件，双击运行即可\u0026mdash;适用于 windows 系统） 1 2 3 @echo off hugo server -D pause 一键启动本地服务器脚本（将以上命令写入脚本（.bat）文件，双击运行即可\u0026mdash;适用于 windows 系统） 报错处理 此报错发生于 git push 时（并非网络问题）\n解决方法：\n重设当前分支为 main(git branch -m 旧分支名 main) 检查 git push source main 中 main 拼写是否正确 此报错发生于 git push 时（网络问题）\n解决方法：更换未污染的 DNS 或添加代理\n参考链接 莱特雷-letere 个人博客\nJules in Spring 个人博客\nGit 切换到指定远程分支\nGit 常见错误简单解决方法\n","date":"2025-07-02T09:51:12+08:00","permalink":"https://axppk.github.io/p/%E9%A6%96%E6%AC%A1%E5%B0%9D%E8%AF%95%E9%83%A8%E7%BD%B2hugo%E5%88%B0github/","title":"首次尝试部署Hugo到Github"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://axppk.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_9e6bcf9cfe9a9448.jpg","permalink":"https://axppk.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://axppk.github.io/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu_55222a4565f8ab23.jpg","permalink":"https://axppk.github.io/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"https://axppk.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://axppk.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu_25e98f89e1c69204.jpg","permalink":"https://axppk.github.io/p/emoji-support/","title":"Emoji Support"}]